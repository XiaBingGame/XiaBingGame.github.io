<html>
<head>
    <link rel="Stylesheet" type="text/css" href="../../../../../../style.css" />
    <title>C++Primer</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
</head>
<body>
<div id="all">
<div id="header">
	<ul id="top-nav">
		<li>
			<a href="file:///D:/Documents and Settings/Vimwiki/Vimwiki_html/index.html">首页</a>
		</li>
		<li>
			<a href="file:///D:/Documents and Settings/Vimwiki/Vimwiki_html/diary/diary.html">日记</a>
		</li>
	</ul>
</div>
</div>
    <div class="content">
    
<h1 id="toc_1">第15章 面向对象编程</h1>
<ul>
<li>
多态性仅用于通过继承而相关联的类型的引用或指针

<li>
定义为 virtual 的函数是基类期待派生类重新定义的函数, 希望派生类继承的函数不能定义为虚函数.

<li>
C++中, 通过基类的引用(或指针)调用虚函数时, 发生动态绑定. 引用(或指针)既可以指向基类型对象也可以指向派生类对象, 用引用(或指针)调用的虚函数在运行时确定, 由引用(或指针)所指对象实际类型所定义的.

<li>
继承层次的根类一般都要定义虚析构函数.

<li>
对非虚函数的调用在编译时确定, 任意非static成员函数都可以是虚函数, 保留字 virtual 只在类内部的成员函数声明中出现, 不能用在类定义体外部出现的函数定义上.

<li>
一个派生类对象只能访问其基类的protected成员, 但不能访问其基类对象的protected成员, 注意对象二字. 另该派生类对象可以访问其他派生类对象的protected成员
<pre class="brush: c++">
//Item_base 是基类, Bulk_item 是派生类. price 是基类中定义的保护数据成员
void Bulk_item::memfcn(const Bulk_item &amp;d, const Item_base&amp; b)
{
	double ret = price; // 可以访问自身的 price
	ret = d.price;		// 可以访问同类对象的保护成员
	ret = b.price;		// 错误, 不能访问基类对象的保护成员
}
</pre>

<li>
派生类中虚函数的声明必须与基类中的定义方式完全匹配. 但有一个例外.

<ul>
<li>
返回基类型的引用(或指针)的虚函数

<li>
派生类中对应的虚函数可以返回基类型所返回类型的派生类的引用或指针

<li>
Item_base 类中有一个虚函数返回 Item_base* 类型. Bulk_item 类中对应虚函数可设置返回 Item_base* 类型或者 Bulk_item* 类型.

</ul>
<li>
一旦函数在基类中声明为虚函数. 它就一直为虚函数. 派生类无法改变该函数为虚函数这一事实. 所以派生类重定义虚函数时, 可以使用 virtual 保留字, 也可以不使用 virtual 保留字.

<li>
每个派生类对象都有基类部分, 类可以访问其基类的 public 和 protected 成员

<li>
已定义的类才能作为基类(只有声明而无定义的类则不行).

<li>
如果需要声明(但不实现)一个派生类, 则声明包含类名但不包含派生列表. 例如:
<pre class="brush: c++">
class Bulk_item;	// 基类
class item_base;	// 派生类
</pre>

<li>
触发动态绑定的两个条件: (1) 只有指定为虚函数的成员函数才能进行动态绑定. (2) 必须通过基类类型的引用或指针进行函数调用.

<li>
基类类型引用和指针的关键在于静态类型(static type, 在编译时可知的引用类型或指针类型)和动态类型(dynamic type, 指针或引用所绑定的对象的类型, 这是尽在运行时可知的)可能不同.

<li>
可以用基类类型的指针或引用来引用派生类型对象, 即动态绑定. 如果调用非虚函数, 无论实际对象是什么类型, 都执行基类类型所定义的函数, 即使派生类实现了该函数的自己版本, 也会调用基类中的函数.

<li>
非虚函数总是在编译时根据调用该函数的对象, 引用或指针的类型而确定.

<li>
覆盖虚函数机制, 可以使用作用域操作符覆盖虚函数机制并强制函数调用虚函数的特定版本, 例如:
<pre class="brush: c++">
Item_base *baseP = &amp;derived;	// derived 为派生类对象
double d = baseP-&gt;Item_base::net_price(42);		// 如果不使用作用域操作符, 则会默认使用派生类的net_price()函数
</pre>

<li>
使用覆盖函数机制, 常用在派生类函数中调用基类同名函数, 用于完成基类版本中的公共任务.

<li>
虚函数和默认实参的关系, 如果虚函数具有默认实参, 调用该虚函数时, 所用的默认实参由调用该函数的类型所决定, 与对象的动态类型无关. 例如基类的指针或引用调用该虚函数时, 默认实参为在基类虚函数声明中指定的值. 如果通过派生类的指针或引用调用虚函数, 则默认实参是在派生类的版本中声明的值.

<li>
在同一虚函数的基类版本和派生类版本中使用不同的默认实参几乎一定会引起麻烦.

<li>
公用, 私有和受保护的继承, 公用继承中, 基类成员保持自己的访问级别. 受保护继承, 基类的public和protected成员在派生类中为protected成员. 私有继承中, 基类的所有成员在派生类中为private成员. 派生类的这三种访问标号控制的是派生类的用户对从基类继承而来的成员访问权限.

<li>
派生访问标号控制派生类的用户对从基类继承而来的成员的访问.

<li>
public派生类继承让派生类具有和基类一样的接口(公有成员), 因此为接口继承. 而private和protected继承使得派生类不具有基类的接口, 称之为实现继承.

<li>
派生类可以恢复继承成员的访问级别, 但不能比基类中的访问级别更严格或更宽松. 使用 using 声明恢复访问级别. 例如:
<pre class="brush: c++">
class Base{
public:
	std::size_t size() const { return n; }
protected:
	std::size_t n;
};

class Derived : private Base{
public:
	using Base::size;
protected:
	using Base::n;
	// ...
};
</pre>

<li>
默认继承保护级别, class 默认为 private 继承, struct 默认为 public 继承, 且 class 默认的成员保护级别为private, struct 为public.
<pre class="brush: c++">
class Base { /* ... */ };
struct D1 : Base { /* ... */ };	// public 继承
class D2 : Base { /* ... */ }; // private 继承77
</pre>

<li>
友元可以访问类的 private 和 protected 数据, 友元关系不能继承. 基类的友元对派生类的成员没有特殊访问权限. 如果基类成为其他类的友元类, 该基类的派生类不能访问授予友元关系的类.

<li>
如果基类定义了 static 成员, 则在整个继承层次中只有这样一个成员, 不会产生拷贝. 既可以通过基类访问 static 成员, 也可以通过派生类访问 static 成员. 既可以通过作用域操作符"::"也可以使用点或箭头成员访问操作符访问 static 成员.

<li>
存在从派生类型引用到基类类型引用的自动转换, 没有从基类引用到派生类引用的自动转换, 指针也是如此.

<li>
如有一个派生类的对象, 则可使用它的地址赋值或初始化一个基类的指针. 也可以使用该派生类的引用或对象初始化基类类型的引用.

<li>
可以使用派生类型对象对基类对象进行赋值或初始化

<li>
引用转换和对象转换的区别: 将对象传递给接受引用参数的函数, 引用直接绑定到该对象, 对象并未复制. 派生类对象传递给接受基类引用参数的函数, 该对象仍为派生类对象. 如果将派生类对象传递给接受基类参数的函数, 则派生类的基类部分被复制到形参.

<li>
用派生类对象对基类对象进行初始化和赋值, 两种情况: 

<ol>
<li>
基类显式定义了派生类型对象复制或赋值给基类对象的函数.(少见) 

<li>
由于复制构造函数和重载的赋值操作符其形参都是为基类类型的引用, 因此将派生类对象引用转换为基类对象引用, 而后调用基类的复制构造函数或赋值操作符.

</ol>
<li>
要确定派生类到基类的转换是否可访问, 可以考虑基类的public成员是否可访问.

<li>
如果派生类是通过public继承基类, 则用户代码和后代类可以使用派生类到基类的转换; 如果类是使用private或protected继承派生的, 则用户代码不能将派生类对象转换为基类对象. 如果派生类是protected继承, 则后续派生类的成员可以转换为基类类型.; 如果是private继承, 则从private继承类派生的类不能转换为基类. 

<li>
无论是什么派生访问标号, 派生类本身的成员和友元总是可以访问派生类到基类的转换.

<li>
不存在基类对象到派生类对象的自动转换. 基类指针或引用绑定到派生类对象时, 其指针或引用转换也存在限制. 如果知道基类到派生类的转换是安全的, 则使用 &lt;static_cast&gt;强制转换. 也可以使用 &lt;dynamic_cast&gt; 申请运行时进行检查.
<pre class="brush: c++">
Bulk_item bulk;
Item_base* itemP = &amp;bulk;
Bulk_item* bulkP = itemp;	// 出错, 即使该指针实际上指向了派生类对象.
</pre>

<li>
构造函数和复制控制成员不能继承.

<li>
派生类的构造函数

<ul>
<li>
合成的派生类默认构造函数, 首先调用基类的默认构造函数, 而后用常规变量初始化规则初始化派生类的数据成员.

<li>
定义默认构造函数, 首先调用基类的默认构造函数, 而后调用派生类的默认构造函数

<li>
向基类构造函数传递实参, 在派生类的初始化列表中包含基类的构造函数. 其首先调用基类的构造函数, 然后根据声明次序初始化派生类的成员.

</ul>
<li>
一个类只能初始化自己的直接基类. 派生类构造函数不能初始化基类的成员且不应该对基类成员赋值.

<li>
复制控制的合成版本, 复制派生类对象时, 调用基类的复制构造函数复制基类部分的数据成员, 而后复制派生部分的数据成员.

<li>
如果派生类定义了自己的复制构造函数, 该复制构造函数一般应显式使用基类的复制构造函数初始化对象的基类部分. 例如

<ul>
<li>
如果复制构造函数初始化列表不是用基类复制构造函数, 则其会默认调用基类的默认构造函数来初始化对象的基类部分.
<pre class="brush: c++">
class Base {/* ... */}
class Derived: public Base {
public:
	Derived(const Derived&amp; d):
		Base(d) {/* ... */}
}
</pre>

</ul>
<li>
派生类赋值操作符, 该操作符必须对基类部分进行显式赋值, 例如
<pre class="brush: c++">
Derived &amp;Derived::operator=(const Derived &amp;rhs)
{
	if(this != rhs)
	{
		Base::operator=(rhs);
		// 清理派生部分的旧值, 分配派生部分的新值.
	}
}
</pre>

<li>
派生类的析构函数只负责清除自己的成员, 不负责撤销基类对象的成员. 撤销顺序首先运行派生类析构函数, 而后依次向上调用各基类析构函数.

<li>
删除一个指针指向的对象时, 指针的静态类型可能与被删除对象的动态类型不同. 比如一个基类指针指向一个派生类对象. 因此有可能调用了基类的构造函数. 因此我们需要将基类的析构函数定义为虚函数, 这样删除对象时会调用正确的析构函数.

<li>
虚析构函数, 基类的析构函数最好为虚拟函数, 当基类指针指向派生类对象时, 删除该对象则可调用正确的析构函数.
<pre class="brush: c++">
Base* item = new Derived;
delete item;	// 如果析构函数为虚拟函数, 则可调用Derived类的析构函数.
</pre>

<li>
三法则: 如果类需要析构函数, 则它也需要赋值操作符和复制构造函数.

<ul>
<li>
基类析构函数是三法则的一个重要例外, 如果基类的析构函数为虚函数, 且为空函数, 则不一定需要赋值操作符或者复制构造函数.

</ul>
<li>
构造函数不能定义为虚函数, 赋值操作符设为虚函数会令人混淆, 而且不会有什么用处. 主要原因在于赋值操作符的形参为所属类自身的引用, 而虚函数则必须在基类和派生类中具有相同的形参.

<li>
构造函数和析构函数内部中的虚函数, 由于在基类的构造函数和析构函数中, 派生类对象都不会完整. 所以如果在构造函数和析构函数中调用虚函数, 运行的是构造函数和析构函数自身类型(所在类)的版本

<li>
在继承情况下, 派生类的作用域嵌套在基类作用域中. 

<li>
对象, 引用或指针的静态类型决定了对象能够完成的行为. 例如一个基类指针指向一个派生类对象, 该指针只能访问该对象的基类部分, 而不能访问该类的派生类部分.
<pre class="brush: c++">
class Disc_item : public Item_base {
public:
	std::pair&lt;size_t, double&gt; discount_policy() const
		{ return std::make_pair(quantity, discount); }
};

Bulk_item bulk; // Bulk_item 是 Disc_item 的派生类
Bulk_item *bulkP = &amp;bulk;
Item_base *itemP = &amp;bulk;
discP-&gt;discount_policy();	// 正确
itemP-&gt;discount_policy();	// 错误, 基类的指针不能访问派生部分
</pre>

<li>
与基类成员同名的派生类成员将屏蔽对基类成员的直接访问, 除非使用作用域操作符访问被屏蔽的基类成员. 设计派生类时, 只要可能, 最好避免与基类成员的名字冲突. 

<li>
基类和派生类中使用同一名字的成员函数时, 即使函数原型不同, 派生类也会屏蔽基类的同名函数. 与局部作用域中声明的函数不会重载全局作用域中的函数一样, 派生类中定义的函数也不会重载基类中定义的成员. 

<li>
如果派生类重定义了基类的重载成员函数, 则只能访问派生类重定义的重载函数, 不能访问基类的重载函数. 所以如果想在派生类中用所有的重载版本,派生类要么重定义所有的重载版本, 要么一个也不重定义.

<li>
如果不想重定义所有的重载成员, 可以使用 using声明, 为基类成员函数名称而做的using声明将该函数的所有重载实例添加到派生类的作用域, 而后派生类只需重定义那些需要的版本即可.

<li>
如果基类定义了一个虚函数,  派生类没有重定义该虚函数, 而定义了其他版本的同名函数, 则在派生类中屏蔽了该基类的虚拟同名函数, 但派生类对象还是继承了该基类的同名虚函数, 这样派生类就有了数个该同名函数版本, 此时用基类的指针指向派生类对象, 可以调用被屏蔽的同名虚函数.

<li>
如何确定函数调用的步骤:

<ul>
<li>
首先确定进行函数调用的对象,引用或指针的静态类型(先向上)

<li>
在该类中查找函数, 如果没有查找到, 则在直接基类中查找, 如此循着类的继承往上查找, 直到找到该函数或者查找完最后一个类.

<li>
找到该函数后, 进行常规类型检查, 即检查实参类型与形参类型是否匹配. 

<li>
如果函数调用合法, 则编译器生成代码, 如函数为虚函数且通过引用或指针调用, 则根据对象的动态类型以运行哪个函数版本.(此时向下)

</ul>
<li>
纯虚函数, 在函数形参表后面写上"=0"以指定纯虚函数, 含有(或继承)一个或多个纯虚函数的类是抽象基类(abstract base class), 除了作为抽象基类的派生类的对象的组成部分, 不能创建抽象基类的对象.
<pre class="brush: c++">
class Disc_item : public Item_base {
public:
	double net_price(std::size_t) const = 0;
};
</pre>

<li>
使用容器保存对象, 如果容器保存基类类型, 则派生类对象会被切掉派生部分, 且没有从基类到派生类的标准转换.唯一可行的选择是使用容器保存对象的指针, 但需要用户管理对象和指针, 必须保证容器存在, 被指向的对象就存在.

<li>
包装(cover)类或句柄(handle)类, 存储和管理基类指针, 用户通过句柄类访问继承层次的操作. 定义句柄类, 三个构造函数-默认构造函数, 复制构造函数, 接受基类对象的构造函数. 第三个构造函数复制基类对象, 只要句柄类存在, 该副本就存在, 用计数来管理副本, 该计数数据成员为指针类型.还有解引用操作符和箭头操作符的定义. 为了实现第三个构造函数, 基类和派生类应该有虚函数clone()用于返回当前对象的副本.

<li>
对于虚函数, 派生类的返回类型必须与基类实例的返回类型完全完全匹配, 但是有一个例外, 如果虚函数的基类实例返回类类型的引用或指针, 则该虚函数的派生类实例可以返回基类实例返回的类型的派生类(或者是类类型的指针或引用)
<pre class="brush: c++">
class Item_base {
public:
	virtual Item_base* clone() const 
		{ return new Item_base(*this); }
};

class Bulk_item : public Item_base {
public:
	virtual Bulk_item* clone() const 
		{ return new Bulk_item(*this); }
};
</pre>

<li>
在关联容器中自动排序元素, 可以通过指定一个函数用作比较函数, 代替&lt;操作符. 
<pre class="brush: c++">
inline
bool compare(const Sales_item&amp; lhs, const Sales_item&amp; rhs)
{
	return lhs-&gt;book() &lt; rhs-&gt;book();
}
</pre>

<li>
关联容器中注意指定比较器类型, 毕竟比较器对象存放在容器中, 以保证对每一个操作使用同一个比较函数
<pre class="brush: c++">
// 定义比较器类型
typedef bool (*Comp)(const Sales_item&amp;, const Sales_item&amp;);
// 关联容器保存比较器对象
std::multiset&lt;Sales_item, Comp&gt; items(compare);
</pre>

</ul>

    </div>
</body>
</html>
