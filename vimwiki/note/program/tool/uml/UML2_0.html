<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<link rel="Stylesheet" type="text/css" href="../../../../style.css">
<title>UML2_0</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
</head>
<body>

<h3 id="toc_0.0.1">6.5.1 是参与者特殊化</h3>
<ul>
<li>
参与者可以使另一个参与者特殊化(specialize, 继承它的行为). 这会给系统用例模型添加更多的表达方式. 例如, 可以把顾客设计为抽象的概念, 会员应根据该概念进行特殊化; 一旦引入了特殊化, 引入非会员的概念就是有意义的.(一般化继承生成特殊化)

<li>
客户必须理解我们生成的制品, 至少要理解从业务建模到静态分析的正确方式.
<pre>
	案例分析
	iCoot 带继承的系统参与者表
	决定给iCoot参与者引入继承后, 完成的系统参与者表如下所示(其中多了一个参与者, 继承关系放在括号中):
		* 顾客: 使用 Web 浏览器访问iCoot的人.
		* 会员: 在一家商店提供了姓名, 地址和信用卡信息的顾客; 每个会员都有一个Internet密码和一个会员号.(特殊化顾客)
		* 非会员: 不是会员的顾客.(特殊化顾客)
		* 助手: 商店的一个员工, 他与会员联系, 告诉他们预约的进展情况.
</pre>

<li>
可以修改用例图, 显示参与者之间的继承关系.

</ul>
<h3 id="toc_0.0.2">6.5.2 用例的关系 </h3>
<ul>
<li>
除了参与者之间的特殊化以及参与者和用例之间的关系外, 用例之间的关系还有特殊化(specialize), 包含(include), 扩展(extend). 这些关系可以组合相关的用例, 分解大的用例, 重用行为, 指定可选的行为.

<ul>
<li>
特殊化: 用例也可以相互继承. 可以只特殊化抽象的用例. (纯)抽象用例根本没有步骤, 其唯一目的是组合其他用例. 如: "U1:浏览索引"和"U4:搜索"都是抽象用例"U13:查找汽车模型"的变体.

<li>
包含: 如果第一个用例有一些第二个用例提供的步骤, 该用例就包含第二个用例. 如"U1:浏览索引"在其行为的某个地方包含了"U2:查看结果"的全部步骤. 

<li>
扩展: 第一个用例给第二个用例增加步骤, 就成为扩展第二个用例. 例如, 查看结果(U2)时, 顾客可以选择查看细节(U3). 扩展关系可以增加可选的额外步骤--通常这些额外步骤位于用例的末尾, 也可以位于用例的开头或中间.

</ul>
<li>
包含与扩展的区别: 包含中, 源用例没有目的用例就不能工作, 扩展中, 源用例没有目的用例也能工作. 
<pre>
	案例分析
	iCoot用例的关系
	用例描述现在如下所示。抽象用例和关系的两端都标识清楚了-----基本原则是，看一下表示法，读者就知道需要查看其他用例，才能完整地理解该用例。
		- U1:浏览索引：顾客浏览汽车型号的索引(特殊化U13，包含U2)。
		- U2:查看结果：给顾客显示检索到的汽车型号子集(被U1和U4包含，被U3扩展)。
		- U3:查看汽车型号的细节：给顾客显示检索到的汽车型号细节，例如描述和广告(扩展U2，被U7扩展)。
		- U4:搜索：顾客指定类别、构造和引擎规格，搜索汽车型号(特殊化U13，包含U2)。
		- U5:登录：会员使用会员号和当前密码登录iCoot(由U6、U8、U9、U10和U12扩展)。
		- U6:查看会员信息：会员查看iCoot存储的会员信息子集如姓名、地址和信用卡信息(扩展U5)。
		- U7:进行预约：会员在查看汽车型号的细节时，预约一种汽车型号(扩展U3)。
		- U8:查看租用情况：会员查看当前租用的汽车汇总信息(扩展U5)。
		- U9:修改密码：会员修改用于登录的密码(扩展U5)。
		- U10:查看预约情况:会员查看还没有结束的预约汇总信息，例如日期、时间和汽车型号(扩展U5，被U11扩展)。
		- U12:注销：会员从iCoot中注销(扩展U5)。
		- U13:查找汽车型号：顾客从目录表中检索汽车型号的子集(抽象，被U1和U4般化)。
</pre>

<li>
用例之间的继承关系以正常方式显示, 即用带有白箭头的线条. 包含关系显示为箭头开放的虚线, 从包含的用例指向被包含的用例, 并标记上关键字<&lt;include&gt;&gt;. 扩展也显示为箭头开放的虚线, 从扩展的用例指向被扩展的用例, 并标记上关键字<&lt;extend&gt;&gt;.

<li>
某些情况下, 扩展关系只能在某些条件具备的情况下存在. 我们可以添加UML注释, 其为任意文本, 在图中用虚线连接相关的点, 终点为一个小圆圈. UML中的条件表示为约束(constraint). 可用自然语言, 伪代码, 或者UML的正式对象约束语言(Object Constraint Language, OCL)表述.
<pre>
	案例分析
	iCoot用例调查(完整)
	任何顾客都可以浏览汽车型号索引(U1)或通过搜索(U4),在目录中查找汽车型号。在后一种情况下，顾客要指定他们感兴趣的类别、构造和引擎规格。无论采用哪种方式，在每次检索后，都会给顾客显示匹配汽车型号的集合(U2)，以及基本信息，例如汽车型号的名称。然后， 顾客就可以选择查看特定汽车型号的其他信息，例如描述和广告(U3).
	顾客有两种情况：会员和非会员.
	已成为会员的顾客可以登录(U5)，访问额外的服务。额外的服务有进行预约(U7)，取消预 约(U11)，检查会员信息(U6)，查看已有的预约(U10)，修改登录密码(U9)，查看已有的租用记 录(U8)和注销(U12)。
	助手涉及到预约的整个过程，例如把汽车开进开出保留区域，
	浏览索引和搜索汽车型号是查找汽车型号(U13)的两种不同方式。为了查看汽车型号的细节，顾客必须查看搜索型号的结果(通过浏览或搜索路径)。
	为了预约汽车型号，会员必须查看其细节(非会员不能预约，即使他们在查看细节也不行)。
	= 要取消预约，会员必须查看已有的预约。 =
</pre>

</ul>

<h3 id="toc_0.0.3">6.5.3 系统用例的细节 </h3>
<ul>
<li>
这里的四个用例细节使用以自然语言编写的一系列步骤. 也可以根据个人喜欢添加更符合算法的结构, 例如条件和循环(例如 if-then-else 和 repeat-until).

<li>
在编写用例的细节时, 必须指定系统的功能, 而不是指定交付功能的方式. 例如, 如果要包含步骤"2. 顾客单击 Detail...按钮", 就要限定用户界面的设计人员. 除非这是绝对要求, 否则就应总是使用中性词与, 例如选择, 启动, 指出和显示.

</ul>

<h3 id="toc_0.0.4">6.5.4 前提条件, 后置条件和继承 </h3>

<h3 id="toc_0.0.5">6.5.5 辅助需求 </h3>
<ul>
<li>
大多数情况下, 可以把非功能需求关联到特定的用例上. 例如, 非功能需求"广告应使用流协议显示, 而不需下载"比较适合"U3:查看汽车型号的细节".

</ul>

<h3 id="toc_0.0.6">6.5.6 用户界面草案</h3>
<ul>
<li>
为系统考虑用户界面有助于阐明用例. 界面可在早期阶段与客户一起讨论, 并把结果记录为用户界面草案(user interface sketches). 这些草案应看为基本指南, 而不是专业的GUI设计, 有助于标识和分解能根据个人喜好来实现的功能.

<li>
这些草案为经过讨论通过, 使用绘图软件包仿制的版本.

<li>
在每个用户界面中, 都应提供对应各个用例的窗口或面板.

</ul>

<h3 id="toc_0.0.7">6.5.7 系统用例的优先级</h3>
<ul>
<li>
实际上, 用例的优先级(紧急程度)不仅取决于期望, 还取决于在当前的递增开发过程中为各个用例投入的系统体系结构和编码工作量.

<li>
给系统用例分配优先级和紧急程度还说明, 应为扩展性和重用性进行开发.

</ul>

<h1 id="toc_1">第7章 分析问题</h1>
<h2 id="toc_1.1">7.1 引言</h2>
<h2 id="toc_1.2">7.2 为什么要进行分析</h2>
<ul>
<li>
不可能仅根据业务需求模型就完全理解问题

<ul>
<li>
因为业务需求模型描述了已有的实现, 只有添加软件, 才可能引入新的实现. 

<li>
另外, 手工工作流和自动(或潜在自动)工作流不是分开的; 例如, 预约汽车型号涉及到人与人和人与计算机的交互操作. 

<li>
这些用例关注的是外部. 用例处理的是参与者和系统边界之间的交互操作----系统本身是一个黑盒子, 嗲有外部才能看到的接口. 

<li>
用例是不严密的; 为了使系统更容易开发和理解, 用例是用自然语言编写的, 因此它们依赖编写人员对语言的理解和作出的某些假设.

</ul>
<li>
当然, 业务需求建模和系统需求建模仍必须完成, 前者可以用于理解业务上下文, 后者能用于与客户达成协议.

<li>
静态分析之后可让客户确认我们对业务对象的理解是否正确, 之后让对象影响我们的设计. 动态分析之后, 可以确信分析对象能够支持需要的系统功能.

</ul>

<h2 id="toc_1.3">7.3 分析过程概述</h2>

<h2 id="toc_1.4">7.4 静态分析 </h2>

<h3 id="toc_1.4.1">7.4.1 确定类 </h3>

<h3 id="toc_1.4.2">7.4.2 标识类的关系</h3>
<ul>
<li>
这些关系出现的频率如下: 关联 &gt; 聚合 &gt; 继承 &gt; 复合

</ul>

<h3 id="toc_1.4.3">7.4.3 绘制类图和对象图</h3>
<ul>
<li>
类图显示了存在哪些类, 这些类有什么关系(正式的类图还可以显示属性和操作). 对于聚合, 复合和关联, 类图显示了允许的运行时关系, 而不是显示实际的运行时关系.

<li>
类名应显示为粗体. 如果类是抽象, 其名称就显示为斜体, 如手工标记抽象类, 在上面或左边加上关键字{abstract}.

<li>
对象标签是有下划线的.

<li>
对象图对于演示某个运行期间的情况很有用, 但它们是可选的.

</ul>

<h3 id="toc_1.4.4">7.4.4 绘制关系</h3>
<h4 id="toc_1.4.4.1">1. 多重性 </h4>
<ul>
<li>
对于复合, 复合端的数字总是1, 因为根据UML规则, 复合的对象不能在复合体中共享, 因此, 在这种情况下, 数字1就是多余的. 在其他情况下, 如果没有显示数字, 就必须假定没有指定它, 或者在这个阶段, 该数字是未知的. 假定某个遗漏的数字隐含着某个默认值(如1)是错误的.
<pre>
	在图7-7中，可以推断出：
	* Car 有—个 Engine。
	* Engine 是 Car 的一部分。
	* Car 有 4 或 5 个 Wheel。
	* 每个Wheel都是Car的一部分，
	* Car总是由一个Body组成。
	* Body总是Car的一部分，它随着Car—起消亡。
	* Car可以有任意多个Driver。
	* Driver至少可以驾驶一辆Car。
	* Car在某一时刻至多有7位Passenger。
	* 一位Passenger在某一时刻只能在一辆Car上。
</pre>

<li>
复合的对象不能同时是两个对象的一部分, 即使复合的对象是独立的, 复合体本身被删除时, 就要删除复合的对象, 这会强制共享.

<li>
UML禁止先创建复合的对象, 再把对象传送给复合的构造函数.

<li>
当有明显的部分-整体关系时, 最好使用聚合, 复合应用于有明显的共享生存期的情形.

<li>
从设计的角度来看, 要在内部隐藏委托对象, 而不是从另一个类中集成, 以便给对象添加行为时(例如之前的Stack和LinkedList), 复合也是很有用的.

<li>
从实现的角度来看, 一对多和多对多关系常常需要在运行期间使用集合对象(列表, 树, 集等), 例如, Car可以使用某种List对象来处理其乘客.

</ul>

<h4 id="toc_1.4.4.2">2. 关联标签, 角色和注释 </h4>
<ul>
<li>
除继承之外的所有关系都可以给定一个关联标签, 它表示关联的性质.

</ul>

<h3 id="toc_1.4.5">7.4.5 属性 </h3>
<ul>
<li>
如果这个阶段不能为属性提供简短的描述, 该属性就应分拆为几个属性, 甚或自成一类.

<li>
在设计阶段, 使用数组可能比较多, 但仍需要小心, 不要因为改进性能而牺牲好的样式.

<li>
就UML而言, 属性和关联(所有三个变体)都只是类的属性. 换言之, 每个属性都可以显示为属性, 或者显示为把属性名作为角色的关联(把原型值或数组作为关联会很奇怪, 所以一般只作为属性). 这意味着, 可以在类型名的后面给属性添加多重性, 例如*表示多值属性, [0...1]表示可选属性.

</ul>

<h3 id="toc_1.4.6">7.4.6 关联类 </h3>
<ul>
<li>
关联类可以和关联一起引入, 如图7-13. 一个CarModel可以与任意多个Customer对象关联, 一个Customer也可以与任意多个CarModel对象关联. 对于每个链接, 都有一个对应的Reservation对象, 它包含号码, 时间戳, 状态. 本例没有给关联指定名称, 因为它隐含在关联类Reservation的名称中. 

<li>
关联类表示关联的信息或行为.

<li>
关联类表示的属性和操作仅因为关联类存在而存在, 属性和操作与关联两端的对象都无关. 例如, 顾客预约时, 在运行期间Customer和对应CarModel之间建立一个新链接, 在需求捕捉和分析阶段, 必须记录下预约号, 时间戳和状态. 但这些属性对Customer和CarModel都没有什么意义, 它们位于这两个对象之间, 所以使用关联类比较合适.

<li>
设计时用更具体的类代替关联类.

</ul>

<h3 id="toc_1.4.7">7.4.7 有形对象和无形对象 </h3>
<ul>
<li>
一般, 每种无形对象有许多有形对象.

<li>
把有形产品和无形产品只建立为一个对象是一个常见的错误. 例如, 汽车经销商的销售系统. 图7-14中, 其中只建立了一个汽车对象, 但是实际上有两个"汽车"概念, 目录表中的汽车是无形的, 它描述了该类型的所有汽车的特性, 但这种汽车可能还不存在. 而顾客拥有的汽车是有形的, 它肯定存在, 因为它可以驾驶, 与另一个顾客拥有的同类型汽车是不同的.

</ul>
<h4 id="toc_1.4.7.1">1. 错误的建模 </h4>
<ul>
<li>
图7.17, 选择A则有一半的属性没用, 选择B, 则每个对象只能为一辆"Alpha Rodeo 156 2.0"型汽车提供服务.

<li>
可以看出, 无形的汽车类型可用于一般化. 具体的汽车则可用于每个顾客的服务.

</ul>

<h4 id="toc_1.4.7.2">2. 正确的建模 </h4>

<h3 id="toc_1.4.8">7.4.8 好的对象</h3>
<ul>
<li>
建议在动态分析之前不要过多地关注操作, 但及时记下操作是没有什么害处的.

</ul>

<h2 id="toc_1.5">7.5 动态分析 </h2>
<h3 id="toc_1.5.1">7.5.1 绘制用例的实现过程 </h3>
<ul>
<li>
在通信图和顺序图中都可以记录相同的信息, 但通信图更适合于用例的实现, 因为通信图更容易生成, 而且它们关注的是对象及其连接, 而不是消息传送的顺序.

<li>
这里可以不使用双向交互, 而使用更面向计算机的客户-提供商模式: 参与者启动与边界对象的交互; 对象边界启动与系统对象的交互; 系统对象启动与其他系统对象, 其他系统边界的交互.

</ul>

<h3 id="toc_1.5.2">7.5.2 边界, 控制器和实体</h3>
<ul>
<li>
清晰的通信图把对象显示为带标签的方框. 为了表达额外的信息, UML允许开发人员使用图表来代替方框, 表示对象的特性. 见图 7-22.

</ul>

<h3 id="toc_1.5.3">7.5.3 通信中的元素</h3>

<h3 id="toc_1.5.4">7.5.4 给类添加操作</h3>

<h3 id="toc_1.5.5">7.5.5 职责</h3>
<ul>
<li>
只要发现系统需要的信息或行为, 就应思考"哪个对象负责这个信息或行为?", 信息最终以属性(和对象)的方式出现, 行为最终以操作(和协作)的方式出现.

<li>
双向协作比较复杂, 难以维护. 提供者相对于其客户而言是松耦合. 双向协作会在两个方向上产生强耦合. 本书描述的每个用例的实现都把参与者当作与边界交互的启动者, 而边界又会与实体通信, 这有助于生成客户和提供对象. 当然, 深入系统就会发现, 提供者也可能是一个客户, 客户也可能是一个提供者.

</ul>

<h3 id="toc_1.5.6">7.5.6 状态建模 </h3>
<ul>
<li>
有时实体的生存期非常复杂, 需要显示在状态机图上. 例如, 图7-25显示了iCoot中Reservation的复杂生存期模型. 

<li>
在Reservation创建后, 就处于等待状态, 一旦达到Conclude状态, 在系统中就不再担任任何任务.

<li>
图7-25 用于预订的状态机图的完整描述---状态机调查.
<pre>
	当会员通过Internet预约汽车型号时，Reservation就等待助手来处理(所以顾客可以在没有助手的帮助下进行预约)。如果以后的某个时刻助手发现在停车场的显示区域中有一辆合适的、未预约的汽车，或者顾客返还了一辆汽车，Reservation就变成Notifiable。此时，汽车移动到保留区域。
	如果在一星期内都没有给某个Reservation提供汽车，该Reservation就变成NeedingRenewal:必须电话或亲自通知会员，让他们取消预约，或在下周重新领约。如果会员取消了预约，或在五天内联系不上，Reservation就变成Concluded。
	一旦Reservation变成Notifiable,助手就必须在三天内电话或亲自通知会员。如果联系上顾客，Reservation就变成Collectable,否則就变成Displayable(移动到保留区域的汽车必须返还到显示区域)。
	一旦Reservation变成Collectable，会员就必须在三天内取车；如果会员取了车Reservation 就变成Concluded,否则就变成Displayable。
	一旦Displayable Reservation的汽车返还到显示区域，Reservation就变成Concluded。
	会员可以在任何时候通过Internet电话或亲自取消预约。
	系统会告诉助手当前预约的状态(还未结束)，这样助手就可以采取适当的措施。
</pre>

</ul>

<h1 id="toc_2">第III部分 设计解决方案</h1>

<h1 id="toc_3">第8章 设计系统体系结构</h1>
<h2 id="toc_3.1">8.1 引言</h2>
<ul>
<li>
分析和设计之间有清晰的分界比较好, 可以确保在考虑解决方案之前, 很好地理解问题.

<li>
把分析模型转换为设计模型并没有硬性规则. 

<li>
我们不关心分析对象和设计对象之间是否有严格的对应关系, 只要设计可以得到有效的解决方案即可.

<li>
设计越通用, 与特定技术的关系就越小---这会减少开发人员精通多项技术的需求, 防止使用已废弃或得不到支持的技术. 通用化的缺点是不能从特定技术中获得最大利益.

</ul>

<h2 id="toc_3.2">8.2 设计优先级 </h2>
<ul>
<li>
用例优先级是有帮助的, 用例紧急程度也是有帮助的, 后者在需求阶段使用交通灯来模拟: 绿灯必须完全设计好; 黄灯不必设计, 但必须支持; 红灯禁止设计, 但仍应支持("设计"表示确定解决方案, "支持"表示可能找出合理的解决方案, 这需要进行一些预测).

</ul>

<h2 id="toc_3.3">8.3 系统设计中的步骤</h2>
<ul>
<li>
系统设计注重于从较高的层次来考察任务, 之后进入子系统的设计(第10章).

<li>
系统设计包括如下活动:

<ul>
<li>
选择系统拓扑

<li>
选择技术

<li>
设计并发策略

<li>
设计安全策略: 例如, 考虑顾客的个人数据---必须确保这些数据不被罪犯盗走, 确保数据不会无意展示给其他客户.

<li>
选择子系统部分: 开发一个解决所有问题的系统常常是不切实际的, 我们需要开发若干个软件, 然后确保这些软件可有效地通信. 

<li>
把子系统分解为层或其他子系统

<li>
决定机器, 子系统和层如何通信

</ul>
</ul>

<h2 id="toc_3.4">8.4 选择联网的系统拓扑 </h2>
<h3 id="toc_3.4.1">8.4.1 网络体系结构的简史 </h3>
<h3 id="toc_3.4.2">8.4.2 三层体系结构</h3>
<ul>
<li>
在三层系统上, 任何程序都至少涉及三台机器.

<li>
三层体系结构的优点如下:

<ul>
<li>
分解重要的部分: 任何大型系统都必须考虑安全性, 大量数据的有效管理, 高吞吐量的编程逻辑和简单的用户界面. 为这些部分单独编程, 开发人员的工作就较容易完成, 并可以优化每个部分的设计.

<li>
使用正确的机器完成工作: 并没有什么适合一切工作的计算机. 运行用户界面是一个简单的工作, 不需要大型机, 甚或文件服务器; 执行编程逻辑要使用大量的CPU和内存, 但不需要巨大的磁盘空间, 所以可以使用强大的服务器; 管理大量数据(例如一百万电子顾客)需要目前所有的计算能力和磁盘空间, 所以这需要大型服务器或大型机.

<li>
改进性能: 可以在数据层或中间层复制适当的机器, 将计算负载分散开(负载平衡, load balancing), 每一层都专业化, 以便于优化.

<li>
改进安全性: 三层系统在部署时, 常常使客户机在互联网上运行. 因此, 必须有一个严格的安全策略来保护内部机器, 程序和数据. 在三层体系结构中, 可以确保中间层的安全---阻止外部的无意或恶意攻击. 数据层在防止破坏的中间层的后面, 所以不必保护其通信或硬件; 这意味着数据层更容易编程, 运行也较快.

<li>
保护投资: 中间层可以看作大型机的客户, 以及真正客户的服务器. 这样就可以把原来的系统转换为现代系统.

<li>
灵活: 除了能随意增加和减少机器之外, 如果用三层体系结构设计系统, 部署也会非常灵活. 例如, 只要逻辑分区是正确的, 就可以在一层上开发系统, 然后部署到三层, 二层(中间层和数据层合并起来)或一层(所有三层都合并在一起)上.

<li>
可以容纳不同类型的客户: 客户层机器只需接受用户的输入, 显示系统的结果, 所以可以为不同类型的设备(个人计算机, PDA, 机顶盒, 移动电话等)提供不同的界面. 中间层和数据层在所有设备上的工作不会有变化.

</ul>
</ul>
<h3 id="toc_3.4.3">8.4.3 个人计算机 </h3>
<h3 id="toc_3.4.4">8.4.4 网络计算机 </h3>
<h3 id="toc_3.4.5">8.4.5 互联网和万维网 </h3>
<h3 id="toc_3.4.6">8.4.6 内联网 </h3>
<ul>
<li>
内联网 --- 运行在封闭环境下的"微型互联网". 

<li>
对于大多数内联网, 都可以达到本地的性能, 有安全优势, 还允许员工访问互联网. 为此, 需要使用互联网防火墙.

</ul>
<h3 id="toc_3.4.7">8.4.7 外联网和虚拟私人网络</h3>
<ul>
<li>
如何利用内联网的性能优势和安全优势进行业务对业务的通信? 使用外联网(extranet), 这是一个或多个内联网之间的安全连接. 是"外部内联网"的简称. 建立外联网最简单的方式是, 在每个内联网的边界上运行互联网防火墙上的一个软件, 它执行两个任务:

<ul>
<li>
允许信息在防火墙之间传送.

<li>
使用强大的加密技术保护在互联网上传送的信息.

</ul>
<li>
外联网也成为虚拟私人网络(Virtual Private Network, VPN). 

</ul>
<h3 id="toc_3.4.8">8.4.8 客户机-服务器与分布式体系结构 </h3>
<ul>
<li>
只要连接多台机器或多个软件系统, 就必须在客户机-服务器与分布式体系结构中选择. 

<ul>
<li>
客户机-服务器: 大量小型的简单客户机给几个大型多线程的服务器发送请求, 服务器会处理这些请求.

<li>
分布式(或等对 peer-to-peer)体系结构的特点是, 一组独立的对等机器根据需要在任意方向上通信.

</ul>
<li>
客户机-服务器体系结构最常见的例子是电子商务模型: 顾客的Web浏览器给公司的Web服务器发出请求, 公司的Web服务器给后端系统发出命令. 大多数二层和三层系统都是客户机-服务器.

<li>
分布体系结构的一个例子是, 一个繁重的计算任务散步到许多互联网机器上. 如果需要处理非常多的数据或过程, 而且可以分解这些数据或过程, 就可以把它们分布到独立的机器上.

<ul>
<li>
一个例子为 SETI@home, 非盈利组织, 查找外星人无线电信号.

</ul>
<li>
术语"客户机-服务器"和"分布式"(或"对等")也用于描述软件体系结构, 独立于软件部署到物理机器和网络上的方式. 运行在程序中的对象就是一个好例子: 正常情况下, 把对象编写为可以在不同环境下重用不同客户机对象的服务器, 但对于特定目的的应用程序, 也可以编写以分布方式写作的环境组.

</ul>
<h3 id="toc_3.4.9">8.4.9 用UML描述网络拓扑</h3>
<ul>
<li>
系统体系结构可以用UML在部署图上描述(如图8-6所示). 这个简单的部署图只显示了节点, 通信路径和多重性. 在这个图中, 每个节点都表示一个主机(用UML关键字<&lt;device&gt;&gt;表示). 通信路径表示两个节点以某种方式通信. 节点可以指定多重性, 表示运行期间存在多少个节点; 因此, 在这个图中, 显示了复制的节点(CootServer和DBServer)和繁殖的节点(CootHTMLClient和CootGUIClient).

<li>
部署图类似于类图和对象图, 因为它们都可以显示可能的体系结构(节点类型)和实际的体系结构(节点实例). 在显示节点实例时, 就像对象图中的对象一样, 节点标签也采用 name:Type格式, 也应加下划线. 

<li>
如果大多数部署图是有意义的, 就需要附带的描述. 按照Jacobson格式, 这称为部署调查.

</ul>

<h2 id="toc_3.5">8.5 并发设计</h2>
<ul>
<li>
并发的最简单方式是限制系统或引入额外的业务规则, 尤其是当用户的访问次数没有明显减少时, 就更是如此. 例如, 在iCoot中, 在顾客访问汽车目录时, 不应试图更新它, 而可以在一个独立的数据库中更新目录, 每天切换一次数据库. 这样互联网子系统就可以假定该目录是只读的, 从而使代码更容易编写. 这是对系统的人为限制.

<li>
业务规则也可以使开发人员的工作更容易完成. 实际上, 有时引入业务规则是因为, 没有更好的方法解决问题. 例如, 考虑, 音乐会门票的购买系统. 顾客Fred走进巴黎的预订办公室, 几乎在同时顾客Beryl走近了位于纽约的另一个预订办公室. 两位顾客都决定购买伦敦同一场音乐会的门票, 可惜, 只剩下一张票了. 如何决定谁买到这张票? 两个顾客都在问:"有票吗?" 两个售票员都查看系统, 都回答"有". 现在就有一个竞争; 第一个说"好, 我要一张"的顾客会买到这张票, 这依赖于售货员的效率和从巴黎到纽约到实际服务器位置的网络延迟.

<li>
为了避免顾客对系统不满, 就可以引入一个额外的业务规则: 当售票员查询是否有票时, 如果有, 就临时保留它---该预订一直持续到售票员取消查询或预订过期(例如, 如果售票员没有取消, 临时预订就持续十分钟)为止. 有了这个新的业务规则, 就可以确保, 只有第一个对票务服务器进行虚拟访问的顾客, 才会被告知有票(票务服务器可以把查询和预订合并到一个业务服务器中).

<li>
如果并发情况会给系统带来困难, 在确保该情况不会再有问题之后, 再实现并发操作. 要使系统强壮起来, 因为现实是残酷的.

</ul>

<h2 id="toc_3.6">8.6 安全设计</h2>
<ul>
<li>
安全是一个相当宽泛的术语, 可以分解为五个方面:

<ul>
<li>
私密性: 必须隐藏信息, 只有授权的人才能读取它.

<li>
验证: 需要知道信息从何而来, 以便决定信任或不信任它.

<li>
不能反驳的信息: 这是验证附带的一个功能, 确保信息的初始提供者不能否认它们是信息的来源, 如果事情出错, 这将有所帮助.

<li>
完整性: 必须确保信息在从其来源传送给我们的过程中, 不受到无意或恶意的破坏.

<li>
安全性: 必须控制对资源(例如机器, 过程, 数据库和文件)的访问. 安全性也成为授权(authorization).

</ul>
<li>
在这里, 信息不仅表示数据, 例如业务文档和用户密码, 还表示可执行的代码. 代码是一个问题, 因为它可以通过网络动态加载. 

<li>
正常情况, 运行一段代码时, 操作系统会对代码要做的工作施加某种控制, 如控制对文件, 目录和其他程序的访问.  操作系统其自身有错误和安全漏洞, 另外操作系统提供的控制是比较死板的.

<li>
如果系统通过网络来操作, 安全方面就更重要, 这是因为黑客可以劫持运行在机器上的程序.

</ul>

<h3 id="toc_3.6.1">8.6.1 数字加密和解密 </h3>
<ul>
<li>
数字加密的级别一般表示为位强度(bit strength); 128位加密是目前最低级的加密, 1024位加密是比较理想的.

<li>
数字密钥基于素数. 密钥本身使用数字证书来发布, 在可信任的证书权威机构的帮助下, 证书可以验证密钥, 这样就不会被黑客欺骗了.

<li>
下面说明前面四个安全方面如何使用密码技术实现:

<ul>
<li>
私密性: 在数字加密和解密中, 密钥的安全发布是使用公共和私有密钥对, 证书和证书权威机构来实现.

<li>
验证：这需要使用证书和证书权威机构证明密钥的来源；粗略说，如果可以成功地解密信息，而且知道密钥的来源，就表示信息必然来自与密钥相同的来源。

<li>
不能反驳的信息：验证需要证明密钥的来源，所以，一旦验证了一段信息，这个验证就是不能反驳的。

<li>
完整性：首先，把加密的信息和未加密的信息都传送给客户机。然后，客户机解密其中已加密的信息，并把结果与未加密的信息进行比较一显然，两者应匹配(它们不匹配的几率很小)。因此，可以相信接确的信息。

</ul>
<li>
上面完整性检查有两个问题: 第一, 发送了未加密的信息; 第二, 信息发送了两次(加密的版本和未加密的版本一样大). 通过安全线路来发送信息, 就可以解决第一个问题. 根据消息摘要进行优化, 就可以解决第二个问题---摘要是使用不可逆算法从信息中生成的一个小位串. 我们发送的是加密的摘要, 而不是加密的信息. 最终结果是进行了相同程度的完整性检查, 但信息只发送一次(为便于记录, 加密的摘要成为数字签名).

</ul>

<h3 id="toc_3.6.2">8.6.2 一般安全规则 </h3>
<ul>
<li>
下面是保护(联网)系统时要注意的事项:

<ul>
<li>
防止未经授权就访问服务器，无论是无意还是恶意。

<li>
界定内部网络的敏感信息：敏感信息包括与其他公司交易的业务信息；业务策略；个人信息；信用引用机构的信息；与国家安全相关的信息等。

<li>
防止盗取导出的信息：确保在内联网外部传送的信息只能由指定的接收者读取。

<li>
保护员工和顾客的密码，这不仅是整个安全策略的基础，它们还是高度个性化的。

<li>
防止服务器代码访问不需要的资源。

<li>
防止客户机代码访问不需要的资源：防止未经授权就访问客户的资源，防止客户受到无意的伤害(因为我们希望提供高质量的服务，而不希望客户控告我们)。

</ul>
</ul>

<h2 id="toc_3.7">8.7 分解软件</h2>
<ul>
<li>
我们可以把软件分解为系统, 如果需要, 在分解为自治的子系统, 最后分解为层(也可以称为子系统).

</ul>
<h3 id="toc_3.7.1">8.7.1 系统和子系统</h3>
<ul>
<li>
考虑 Customer 这个概念在公司各个部门如何看待, 如销售,市场,会计,采购,发货等部门. 如果用一个软件系统支持所有这些部门, Customer就会有上百个属性和上百个操作.

<li>
业务应有许多不同的系统, 每个系统都由不同的开发小组来实现, 这样重用对象不当的机会就会降低到最低. 然后, 信息需要在系统间传送, 就应通过设计优良的接口以定义明确的受控方式来传送. 为了进一步降低复杂度, 每个系统还应分解为各个子系统.

<li>
图8-7把一个公司的系统显示为树林中独立的树.

<li>
案例分析中, 有一个系统Coot, 由两个子系统组成: iCoot为会员和非会员提供访问, 另一个子系统为助手提供访问, 且类似于已有的Auk界面.

</ul>

<h3 id="toc_3.7.2">8.7.2 层 </h3>
<ul>
<li>
在软件系统中, 通常采用代码的多个层(见图8-8). 每一层都是一组合作对象, 它们依赖于底层提供的功能. 层不必包含对象, 例如, Unix系统库通过C函数层提供对底层操作系统功能的访问. 

<li>
层将实现过程分解为多个可管理的块, 有助于降低复杂度. 层还提供了重用的可能性, 因为每一层的编写都独立于其上的曾.

<li>
无论层的总数有多大, 最顶层都常常表示用户界面, 最低层表示操作系统或网络连接. 为了简单起见, 省略了最底层, 只显示到一个众所周知的层上, 该层在其他地方介绍.

<li>
层可以打开(显示下层上的一些对象, 供上面的层使用, 例如管理下层中的对象, 但没有完全隐藏它们); 也可以关闭(完全封装下面的层, 例如上面的层完全靠不到底层的对象). 关闭的层需要更多的编码, 运行更慢. 打开的层不太安全, 较难维护(因为每一层的上面都有多个依赖它的层).

<li>
某种程度上, 可以交换各个层, 而不会伤害其他的代码. 例如, 去掉最顶层, 用另一个层代替. 而且, 可以用一个有相同接口的层替换关闭的中间层, 而不会影响上面的层.

<li>
一些技术(第9章详细论述)

<ol>
<li>
单层系统的层

<ul>
<li>
图 8-9 为单层系统采用的一个简单的多层模式.

<li>
数据库层任务为在DMBS和业务层之间来回传送数据. 如果一个更简单的系统在文件中存储数据, 数据库层就是一个文件系统, 而不是DBMS.

<li>
业务层由实体对象和支持实现的对象组成.

<li>
用户界面层包含的对象负责把可用选项显示给用户, 把用户命令和数据传送给业务层, 并显示从业务层传送来的数据.

</ul>
<li>
两层和三层系统中的层

<ul>
<li>
使用网络从运行在客户机上的用户界面到达服务器上运行的业务层.

<li>
网络层包含的对象使网络对用户界面来说是透明的.

<li>
用户界面只能直接访问服务器对象.

<li>
服务器层包含的对象把业务层的使用简化为一组可管理的业务服务.

<li>
除了简化客户机之外, 这还可以本地化服务层上的安全措施, 容纳不同种类的客户机, 而不会影响业务层.

<li>
对于两层系统, 数据库层, 服务器层和业务层都位于相同的机器上. 对于三层系统, 数据库层横跨网络, 但DBMS隐藏了信息.

<li>
如果使用HTML窗体从客户机到达中间(或服务器)层, 用户界面-网络情况就不太清晰. 在这种情况下, 用户界面部分在客户机上(如HTML页面和窗体), 部分在服务器上().

</ul>
<li>
转换层

<ul>
<li>
不同的层有不同的关注点. 

<ul>
<li>
设计用户界面时, 关注的是菜单, 对话框, 笔记本, 窗口, 可用性, 直观性等. 

<li>
对于网络, 关注的是协议, 带宽和不同类型的主机. 

<li>
服务器上, 关注的是安全, 多线程和通过量. 

<li>
业务层上, 其关注可从业务分析中获得, 关注的是抽象, 属性, 多态性, 重用和面向对象建模的其他基础方面. 

<li>
数据库层, 关注的是键, 表, SQL, 锁定, 函数依赖性和数据库理论的其他方面

</ul>
<li>
如果直接把这些不同的层连接在一起, 结果会过于复杂和耦合(强耦合, 一个对象的实现与另一个对象的实现紧密相关, 将使代码难以维护).

<li>
可以引入额外的层, 作为转换器, 来降低复杂度和耦合性. 转换层对于把业务层(单层系统)或网络层(多层系统)转换为最终用户需要的最低功能尤其有帮助---这种层常常称为控制器. 控制器管理着用户界面与系统其他部分的通信(这非常符合Jacobson的控制器概念). 另一个常见的转换层是所谓的持久层, 它位于业务层和数据库层之间, 去除了业务层对所使用的存储机制的依赖, 以后改变存储机制就比较容易了(例如从文件改为DBMS). 图8-12显示了增加了控制层和显示层的多层系统.

</ul>
</ol>
</ul>

<h3 id="toc_3.7.3">8.7.3 Java层: 应用小程序和RMI</h3>
<ul>
<li>
RMI 是一个Java网络协议.

<li>
这个图中, 用户界面层是使用Swing库实现的. 控制层访问业务服务的所有代码; 这些代码必须隐藏在用户界面对象中, 以后添加的每个新界面(例如移动电话)都要重新实现它. RMI框架提供网络层, 在客户机上访问服务器对象. Java数据库连接(JBDC)库提供数据库层. JDBC允许使用动态或预编译的SQL访问任意关系数据库. 因为有持久层, 所以可以用面向对象的数据库或文件系统代替JBDC, 而不会伤害业务对象.
<pre>
	案例分析
	iCoot 层
	为了演示HTML/CGI和服务程序的配置，图8-14显示了用于iCoot的层。
	对于iCoot，没有持久层，因为通过JDBC访问的关系数据库用于在系统的整个生命周期中为系统服务。JDBC层本身由标准Java库中的类提供。对于用户界面，有两种模式：CGI和服务程序、RMI+小程序。对于第一个版本，将在ServletsLayer上使用HTML/CGI和服务程序。对于以后的版本，将使用SwingLayer为桌面提供RMI+小程序机制。小设备，如PDA和移动电话，则使用 MicroLayer, MicroLayer 是使用 Java 2 Micro Edition(J2ME)实现的。
	对于第一个版本，控制层将在JSP的帮助下由服务小程序提供。对于RMI版本，为适当的GUI设计了 ControlLayer。这意味着控制层在HTTP/CGI网络的下面，在RMI网络的上面。在这两种情况下，控制器会转换(或协作)Serverlayer。因此，ServerLayer下面的所有内容都可以不加丝毫修改地重用(ControlLayer也由GUI的两种模式重用）。
</pre>

</ul>
<h3 id="toc_3.7.4">8.7.4 层中的消息流</h3>
<ul>
<li>
在分层的系统中, 每一层都是该层下面一层的客户. 消息从上面的层流向下面的层, 每个消息都是一个问题(检索某种信息, getAddress)或一个命令(做某个工作的指令, 例如setAddress).

<li>
如何让上面的层了解下面的层数据的变化.

<ul>
<li>
给上面的层添加信息, 说明哪个命令改变了什么信息. 其会用逻辑上属于下层的信息影响上面的层--使上层的编码更复杂, 使得上层与下层的耦合更紧密.

<li>
只要信息有变化, 就让下面的层给上面的层发送消息. 下面的层必须对上面的层有所了解, 才知道哪个对象发送了消息, 所以下面的层会受到上面的层的影响, 使下面的层更复杂, 也使得其与上层耦合更紧密.

</ul>
</ul>
<h4 id="toc_3.7.4.1">1. 事件</h4>
<ul>
<li>
当发生了某个有趣的事件时, 该层采用某种方式通知上面的层, 而不在两个方向上增加复杂性或耦合性.

<li>
事件可以是属性事件, 表示事件源的一个属性值发生了变化, 事件也可以是与属性值无关的纯事件.

<li>
事件源检测事件的发生, 并告知正在监听的人.

<li>
在分层模式中, 可以在每一层使用事件源向上面一层的监听者广播事件, 达到把信息保存在正确的位置和最小耦合的目的.

<li>
图 8-17, 显示事件工作原理的通信图

<ol>
<li>
ClockUI给Clock发送addClockListener消息, 注册它自己.

<li>
ClockWatcher在ClockUI上设置警报, 把警报设置传送给Clock.

<li>
Clock定期给它本身传送tick消息, 最终发现到时候该发出警报了. 此时创建一个ClockEvent(在ClockEventHome的帮助下), 并给出事件的信息(这里唯一的信息是事件源).

<li>
Clock给ClockUI发送alarm消息, 并把ClockEvent作为参数(事件对象记录事件源, 如果ClockUI监听多个Clock, 就可以确定是哪个Clock在响).

<li>
最后, ClockUI向ClockWatcher发出鸣响.

</ol>
<li>
通信图上的序号有字母, 这是因为例子中有三个独立的顺序: 添加时钟监听器; 设置时间; 发出警报(只要添加时钟监听器最先发生, 其他两个事件就可以以任意顺序发生多次).

<li>
时钟必须独立于ClockUI和ClockWatcher来运行. 否则设置警报后, 控制就会返回ClockWatcher, Clock就不能tick.

<li>
名称作为UML序-号-的一部分说明, 消息依赖于包含相同名称的消息, 但独立于其他消息. 小心使用数字, 仍可以显示独立消息的书匈奴, 例如, 消息2b在消息3c之前发生. 消息99x和99y同时发生.

<li>
闹钟的类图如图8-18所示(为了简单起见, 省略了ClockEventHome和ClockWatcher). 从这个图中可以看出, ClockEvent是source属性的获取器, ClockUI的一个消息setAlarm允许ClockWatcher设置警报, 另一个消息alarm可以检测警报事件. 最后, Clock类的一个消息setAlarm用于设置警报, 另一个消息 addClockListener用于注册监听者. 

<li>
面向对象的语言一般不必有真正的广播机制, 所以图8-18中的Clock必须维护监听者的内部列表, 当发生事件时, 还必须给每个监听者发送消息. 监听者必须确保它们为事件进行了注册. Clock现在和ClockUI耦合在一起, 这是我们应避免的. 为了解决这个问题, 可以引入一个抽象类 ClockListener, 它只列出检测Clock事件所需的消息. 只要ClockUI继承了ClockListener, 就可以用Clock注册ClockUI, ClockUI也可以接收alarm消息. 因此, 即使Clock和ClockListener耦合在一起, 也不与ClockUI耦合在一起. (ClockListener位于与Clock相同的层上, 而ClockUI在该层的上面).

<li>
用<&lt;interface&gt;&gt;关键字表示的接口是一个纯抽象类, 这种类没有具体的方法, 也没有属性. 接口可以用降低了的耦合性指定通信, 所以在图8-18中有一些特殊的UML表示法. 虚线白箭头(标记为"实现")表示继承, 特殊情况下, 超类是一个接口. ClockListener表示法标记为"提供的接口/需要的接口", 它允许表示一个类通过特定的接口使用另一个类. 本例中, 看起来像棒棒糖的部分表示ClockUI实现(一种)ClockListener, 而辈子形状的部分表示Clock只依赖于ClockUI是一种ClockListener这一点. 

</ul>
<h4 id="toc_3.7.4.2">2. 使用事件的消息流</h4>
<ul>
<li>
一般的消息都是在层中向下流动, 而事件消息是向上流动的.(事件消息显示为虚线箭头, 表示下面的对象对接收者一无所知).

<li>
客户代码常使用事件, 用户界面用下一层的信息更新的简便方式. 事件很少在服务器端使用, 因为服务器代码是多线程的, 会显著增加事件驱动的编程的复杂性(例如, 出现死锁的可能性会增加). 事件不应通过网络来广播; 在给许多客户发送事件消息时, 如果一些客户已损坏或很难联系上, 就不希望服务器阻拦. 因此建议避免在服务器端进行事件驱动的编程. 如果要通过网络来广播, 应使用机器对机器的消息传输方式, 例如Java Messaging Service(JMS)提供的方式.

</ul>

</body>
</html>
