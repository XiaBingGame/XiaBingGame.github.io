<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<link rel="Stylesheet" type="text/css" href="../../../../style.css">
<title>paper</title>
<meta http-equiv="Content-Type" content="text/html; charset=cp936">
</head>
<body>

<h1 id="toc_1">绪论</h1>
<p>
	本项目的主要目标是实现多个人物在一个比较复杂的场景中行走。 其中主要使用到的技术有动画组合， A*寻路算法, 以及有限状态机(FSM)。 本项目基于Ogre图形库开发(Object-Oriented Graphics Rendering Engine)， 该图形库是用C++开发的3D图形引擎。
</p>

<h1 id="toc_2">理论</h1>
<h2 id="toc_2.1">A*寻路算法</h2>
<p>
	A*是当今游戏软件开发中十分常用的一种路径寻找算法，该算法是启发式搜索算法，它可以保证在任何起点及任何终点间找到最佳的路径。
	启发式搜索表示对每一次搜索的位置进行评估，得到最好的位置， 而后再从该位置进行下一步搜索， 知道搜索到目标位置。 在启发式搜索算法中， 如何评估搜索位置非常重要， 这里我们使用下面的公式来计算搜索位置的评估值。
	f(n) = g(n) + h(n).
	其中f(n)是位置n的估价函数， g(n)是从起始位置到达位置n的实际代价， h(n)是位置n到达目标位置的估计代价。 
	由于我们已经预先将地图划分成二维网格图， 所以A*算法从起始位置开始不断循环地访问相邻网格， 计算每个网格的评估值， 从而得到一个最佳的路径到达终点。
</p>
<h2 id="toc_2.2">动画组合</h2>
<p>
	本项目使用的模型含有多个动画，每个动画可以表示成一个独立的动作， 例如不断地循环一个行走动画可以使得人物在场景中不断地行走。 这些动画之间是独立不相关的， 例如行走动画和爬行动画两者是完全不相关的。 当我们需要实现人物一个很复杂的动作时， 比如爬行通过一个障碍物， 就需要将人物转换到爬行状态。 这里我们使用动画组合技术， 实现两个动作的衔接。
	动画组合指的是指将多个动画状态组合在一起形成一个复杂动作。 例如我们将行走动画状态， 站立不动状态， 下蹲动画状态， 爬行动画状态组合在一起，就可以实现一个人物从行走状态转换到爬行状态的复杂动作。 
	在动画组合里面最重要的是两个动画状态之间的转换， 由于每个动画状态由一系列帧组成，所以两个动画状态之间的转换一般为源动画状态的特定帧转换到目标动画状态的特定帧，通常目标动画的特定帧为第一帧。
</p>
<h2 id="toc_2.3">有限状态机</h2>
<p>
	由于本项目的人物面对不同的障碍物会作出不同的动作， 所以我们需要使用有限状态机(FSM, finite-state machine)来管理人物的多个状态。 有限状态机在任何时候只能拥有一个状态. 例如行走之时就不能有其他的状态。本项目运行的时候， 每一帧调用有限状态机的当前状态来更新人物的位置和动画， 并且判断是否触发了其他条件使得当前状态发生了改变。 例如人物行走之时， 前面遇到了河流， 则从行走状态转换到跳跃状态， 以便跳跃过河流。
</p>
	
<h1 id="toc_3">人工智能的设计</h1>
<h1 id="toc_4">A*寻路算法的设计</h1>
<h2 id="toc_4.1">准备工作</h2>
<p>
	首先需要将场景划分成许多大小相同的网格, 并将每个网格初始化成平地。 其次， 在读取场景数据的时候，根据场景数据修改对应网格为只能绕行的障碍物、可以跳跃过去的障碍物、只能爬行通过的障碍物。最后，设置需要查找路径的起点和终点，而后使用A*算法查找一条从起点到终点的最短路径。
	另外， 由于跳跃和爬行的代价要比走路的代价高， 所以我们还需要将跳跃和爬行的代价作为A*算法的输入值。
</p>
<h2 id="toc_4.2">使用A*算法查找最短路径</h2>
<p>
	加载完场景数据之后，场景划分的各个网格则被初始化成四种地形类型， 分别为平地网格， 只能爬行通过的网格， 只能跳跃通过的网格， 以及只能绕行的网格。可以使用二维数组或者一维数组保存这些网格数据。 本项目使用一维数组保存网格数据， 假设整个场景中横坐标有X个网格， 纵坐标有Z个网格， 访问第i行第j列的网格则使用索引 i*X+j 访问。现在我们需要求出从起点到终点的最短路径。
	首先需要设计两个表， 分别为 Open 表和 Close 表， 其中 Close 表保存已经访问过的网格， Open 表则保存所有考虑过但是还没有访问的网格。而后我们设计在场景中移动的代价。从一个网格平行或者垂直移动到 
	从起点开始访问， 将起点网格放入Close表中。 接下来开始考虑起点网格八个方向的相邻网格， 如下图所示， 八个相邻网格只要其不为只能绕过的障碍物网格则将其放入Open表中，且将起点网格设置成该相邻网格的父亲网格。 而后我们根据估计公式来计算每个相邻网格要到达终点可能花费的代价，其中估计公式为 F(n) = G(n) + H(n)。 G(n)为起点网格沿着访问路径到达该网格已经花费了的代价。 假设该网格为平地类型， 如果他的父亲网格在他的斜对面， 则父亲网格到该网格的代价为14， 否则代价为10， 即水平移动或者垂直移动的代价为10. 具体见下图所示。 假设该网格为只能跳跃通过的网格， 则还需要加上跳跃通过的代价， 该值可以通过程序的Setting界面中的Jump Cost 滑块设置。 如果该网格为只能爬行通过的网格， 同上， 还需要加上爬行的代价。 这两个代价的值越高， A*算法则越不可能选择该网格作为路径上的一点。
	H为该网格到达目标网格可能要花费的代价， 该值一般只是一个猜测， 假设路径终点的网格坐标为(X1, Z1), 当前正在考虑的网格坐标为(X0, Z0), 则 H = 10 * ABS(X1-X2) + ABS(Z1-Z2), ABS()表示取绝对值， 这个方法为 Manhattan 方法， 这是一种理想状态下不需要绕路直接走到目标位置的代价（不能斜线行走）。
	最后G值和H值的和为该网格的F值。 求出Open表中的所有网格F值， 而后进行排序， 最小的元素放在Open表的第一个位置。 由于需要不断的插入元素到Open表中， 所以这里使用插入排序算法， 并使用链表结构存储每个网格。
	现在选择Open表格中F值最小的元素， 即第一个元素， 将其从Open表中删除， 而后访问该元素， 而后将其放入 Close 表中表示该元素访问过了。 同上访问该网格的八个相邻网格， 如果相邻网格不为只能绕行的障碍物， 且不在Open表和Close表中， 则将该网格设置为该相邻网格的父网格， 并将该相邻网格放入Open表中。 如果该相邻网格在Open表中，则可以计算从该网格到该相邻网格的G值， 如果G值更小， 则将该网格设置为该相邻网格的父网格， 并更新该相邻网格的G值和F值， 具体见下图所示。 由于F值发生了变化， 所以还需要对Open表进行重新排序。
	现在不断地访问Open表中最小的元素， 不断的考虑该网格的相邻网格， 知道访问的网格等于路径终点网格， 或者Open表为空， 这表示无法到达最终节点， 查找路径失败。
	在本例中， 我将水平或者垂直行走一个网格的代价为10， 斜线行走一个网格的代价为14. 且还会考虑跳跃和爬行的代价， 如果跳跃或者爬行的代价太过高昂， 则A*算法则可能选择绕路， 而不会选择跳跃或者爬行。
</p>

<h1 id="toc_5">Ogre库</h1>
<p>
	Ogre 3D是一个成熟，稳定，可靠，灵活，跨平台，而且拥有丰富功能实时3D图形库。本项目使用的Ogre版本为1.7.2. 
</p>
	
<h2 id="toc_5.1">有限状态机和动画的组合</h2>

<h1 id="toc_6">组合动画</h1>
<p>
	在Ogre中每个人物模型可以拥有多个动画状态，本项目忍者角色使用了行走，爬行，下蹲，跳跃这四个动画状态， 每个动画状态有一系列帧组成（解释： 可以使用OgreMeshy工具查看动画， 动画状态可以通过时间选择某一帧的内容）。我们需要组合多个动画状态， 使得人物能够自然流畅地从一个动画状态转换到另一个动画状态， 从而能够在场景中面对不同的障碍物作出合适的行为。 例如当人物正在行走之时， 前面遇到一个可以爬行通过的障碍物， 根据A*算法和有限状态机的处理结果， 人物选择爬行通过该障碍物。 在爬行之前， 我们需要组合一系列的动画状态， 实现行走状态到爬行状态的转换。
	为了实现从行走状态到爬行状态的转换，我们进行以下步骤：
	（1）首先从行走状态的当前帧慢慢转换成静止站立状态. 
	（2）从静止站立状态转换成下蹲动画状态的第一帧 
	（3）运行下蹲动画， 使得人物下蹲至最低点 
	（4）从下蹲状态的当前帧转换成爬行动画状态的第一帧。
	本项目为了实现两个动画状态的转换， 主要使用权重值来混合两个动画状态的当前帧。 假设从动画状态A转换至动画状态B，则动画状态A的初始权重值为1.0， 动画状态B的初始权重值为0.0, 且假设当前帧距离上一帧的时间为t， 则每一帧的更新处理伪代码如下：
</p>
<pre c++>
	动画状态A的权重值 = 动画状态A的权重值 - t * 动画状态转换速度
	动画状态B的权重值 = 动画状态B的权重值 + t * 动画状态转换速度
	if (动画状态A的权重值 &lt;= 0)
		禁止动画状态A
	if (动画状态B的权重值 &gt;= 1)
		动画状态转换结束
</pre>
<p>
	实现从爬行状态到行走状态的转换， 步骤和上面的转换相反， 步骤如下：
	（1） 从爬行状态的当前帧转换至下蹲动画状态在最低点位置的那一帧， 即下蹲动画状态0.48秒时的位置， 可通过函数 Ogre::AnimationState::getTimePostion()获得该帧。
	（2） 运行下蹲动画， 使得人物能够站起来
	（3） 实现下蹲动画状态的当前转到静止站立状态的转换
	（4） 从静止站立状态转换至行走动画状态的第一帧。
	这里我们还要实现跳跃障碍物的动作， 由于不可能人物在空中持续跳跃， 所以要实现跳跃障碍物的动作， 其转换为为行走到跳跃， 最后从跳跃转换至行走。 步骤如下：
	（1） 行走状态的当前帧转换至静止站立状态
	（2） 静止站立状态转换至跳跃动画状态的第一帧
	（3） 运行跳跃动画， 并更新人物位置， 实现人物在空中飞跃障碍物
	（4） 跳跃动画运行至最后一帧， 转换至静止站立状态
	（5） 从静止站立状态转换至行走状态， 继续行走。
	具体函数代码实现见NinjaCharacter::animationStep， 
</p>

<h1 id="toc_7">有限状态机</h1>
<p>
	程序有多个状态， 分别为行走状态， 爬行状态， 正在转换状态， 站立不动状态。
</p>
	

<h1 id="toc_8">代码实现</h1>


<h1 id="toc_9">参考</h1>
<p>
<a href="http://www.policyalmanac.org/games/aStarTutorial.htm">http://www.policyalmanac.org/games/aStarTutorial.htm</a>
</p>

</body>
</html>
