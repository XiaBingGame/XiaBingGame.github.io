<html>
<head>
    <link rel="Stylesheet" type="text/css" href="../../../../../style.css" />
    <title>Chapter07</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
</head>
<body>
<div id="all">
<div id="header">
	<ul id="top-nav">
		<li>
			<a href="file:///F:/NetShare/BaiduYun/百度云/Vimwiki/Vimwiki_html/index.html">首页</a>
		</li>
		<li>
			<a href="file:///F:/NetShare/BaiduYun/百度云/Vimwiki/Vimwiki_html/diary/diary.html">日记</a>
		</li>
	</ul>
</div>
</div>
    <div class="content">
    
<h1 id="toc_1">OpenGL  7 OpenGLеͼ</h1>
<h2 id="toc_1.1"></h2>
<p>
	ùդλ            glRasterPos, glWindowPos<br />
	λͼ                glBitmap<br />
	ȡдɫͼ        glReadPixels, glDrawPixels<br />
	Ŵ, ͷתͼ    glPixelZoom<br />
	ɫĲ            glPixelTransfer, glPixelMap<br />
	ִɫ滻            glColorTable<br />
	ִи߼ͼ        glConvolutionFilter2D<br />
	ռͼͳϢ        glHistogram, glGetHistogram<br />
<br />
	<strong>λͼɫglRasterPosglWindowsPosʱõ</strong>, ζglColorõĵǰɫںλͼ, , ڹդλѾ֮ٵglColorλͼɫӰ<br />
<br />
</p>
<h2 id="toc_1.2">ذװ</h2>
<p>
	ȱʡ, OpenGL4ֽڵĶ.<br />
	ʹĺ޸λͼͼĴ洢صķʽ<br />
		void glPixelStorei(GLenum pname, GLint param);<br />
		void glPixelStoref(GLenum pname, GLfloat param);<br />
	GL_UNPACK_ALIGNMENTָOpenGLδݻжͼݽн<br />
	GL_PACK_ALIGNMENTָOpenGLδɫȡݽаװ. һûָڴ滺.<br />
<br />
</p>
<h2 id="toc_1.3">ͼ</h2>
<p>
	ͼɳ1λĴ洢ռʾ, ÿЩλԴ洢صǿ(Ϊֵ)ɫɷֵ<br />
	ͼĺ:<br />
		void glDrawPixels(GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels)<br />
	úԹդλýи.<br />
</p>
<pre c++>
////////////////////////////////////////////////////////////////////
// ڴTGA, ػָ
// ĸ߶ȺͿ, ԼOpenGLݸʽ
// ʱfree()ͷŻ
// ֻͨtargaͼ
// 8λ, 24λ32λ, ʹõɫ, ܵRLE
GLbyte *gltLoadTGA(const char *szFileName, GLint *iWidth, GLint *iHeight, GLint *iComponents, GLenum *eFormat)
{
    FILE *pFile;                        // ļָ
    TGAHEADER tgaHeader;                // TGA ļͷ
    unsigned long lImageSize;           // ļĴС(ֽڼ)
    short sDepth;                       // 
    GLbyte      *pBits = NULL;          // ָλָ

    // ȱʡ/ʧֵ
    *iWidth = 0;
    *iHeight = 0;
    *eFormat = GL_BGR_EXT;
    *iComponents = GL_RGB8;

    // ļ
    fopen_s(&amp;pFile, szFileName, "rb");
    if(pFile == NULL)
        return NULL;

    // ȡļͷ
    fread(&amp;tgaHeader, 18/* sizeof(TGAHEADER)*/, 1, pFile);

    // Դ˺Сֽ˳ֽڽ
#ifdef __APPLE__
    LITTLE_ENDIAN_WORD(&amp;tgaHeader.colorMapStart);
    LITTLE_ENDIAN_WORD(&amp;tgaHeader.colorMapLength);
    LITTLE_ENDIAN_WORD(&amp;tgaHeader.xstart);
    LITTLE_ENDIAN_WORD(&amp;tgaHeader.ystart);
    LITTLE_ENDIAN_WORD(&amp;tgaHeader.width);
    LITTLE_ENDIAN_WORD(&amp;tgaHeader.height);
#endif


    // ȡĸ߶, Ⱥ
    *iWidth = tgaHeader.width;
    *iHeight = tgaHeader.height;
    sDepth = tgaHeader.bits / 8;

    // ڴ˽һЩЧ֤. ֻ8, 2432λtargaͼ
    if(tgaHeader.bits != 8 &amp;&amp; tgaHeader.bits != 24 &amp;&amp; tgaHeader.bits != 32)
        return NULL;

    // ͼ񻺳ĴС
    lImageSize = tgaHeader.width * tgaHeader.height * sDepth;

    // ڴ
    pBits = (GLbyte*)malloc(lImageSize * sizeof(GLbyte));
    if(pBits == NULL)
        return NULL;

    // ȡλ
    if(fread(pBits, lImageSize, 1, pFile) != 1)
    {
        free(pBits);
        return NULL;
    }

    // OpenGLʽ
    switch(sDepth)
    {
        case 3:     // ֵܳ
            *eFormat = GL_BGR_EXT;
            *iComponents = GL_RGB8;
            break;
        case 4:
            *eFormat = GL_BGRA_EXT;
            *iComponents = GL_RGBA8;
            break;
        case 1:
            *eFormat = GL_LUMINANCE;
            *iComponents = GL_LUMINANCE8;
            break;
    };


    // ɶļĲ
    fclose(pFile);

    // ָͼݵָ
    return pBits;
}
</pre>
<p>
ȡ.<br />
</p>
<pre c++>
	void glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height,
    	GLenum format, GLenum type, GLvoid *pixels);
</pre>
<p>
<br />
	void glCopyPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum type);<br />
<br />
ȱʡ, ˫Ⱦ, Щزں󻺳. Ⱦ, ǰн.<br />
ʹº޸زԴĿ<br />
	void glDrawBuffer(GLenum mode);<br />
	void glReadBuffer(GLenum mode);<br />
</p>
<pre c++>
// ׽ǰӿ, Ϊһtargaļ
// ڵ֮ǰ, ˫Ļ, ȷŵSwapBuffers.
// ڵĻ, ȷŵglFinish
// ˴, 0, 򷵻1
GLint gltWriteTGA(const char *szFileName)
{
    FILE *pFile;                    // ļָ
    TGAHEADER tgaHeader;            // TGA ļͷ
    unsigned long lImageSize;       // ͼС
    GLbyte      *pBits = NULL;      // ָ
    GLint iViewport[4];             // ӿڴС
    GLenum lastBuffer;              // ڴ洢ǰȡ

    // õǰӿڴС
    glGetIntegerv(GL_VIEWPORT, iViewport);

    // ͼĴС
    lImageSize = iViewport[2] * 3 * iViewport[3];

    // ڴ
    pBits = (GLbyte *)malloc(lImageSize);
    if(pBits == NULL)
        return 0;

    // ɫжȡ
    glPixelStorei(GL_PACK_ALIGNMENT, 1);
    glPixelStorei(GL_PACK_ROW_LENGTH, 0);
    glPixelStorei(GL_PACK_SKIP_ROWS, 0);
    glPixelStorei(GL_PACK_SKIP_PIXELS, 0);

    // ȡǰȡòб
    // лǰжȡ
    // , ָȡ״̬
    glGetIntegerv(GL_READ_BUFFER, (GLint *)&amp;lastBuffer);
    glReadBuffer(GL_FRONT);
    glReadPixels(0, 0, iViewport[2], iViewport[3], GL_BGR_EXT, GL_UNSIGNED_BYTE, pBits);
    glReadBuffer(lastBuffer);

    // ʼTarga
    tgaHeader.identsize = 0;
    tgaHeader.colorMapType = 0;
    tgaHeader.imageType = 2;
    tgaHeader.colorMapStart = 0;
    tgaHeader.colorMapLength = 0;
    tgaHeader.colorMapBits = 0;
    tgaHeader.xstart = 0;
    tgaHeader.ystart = 0;
    tgaHeader.width = iViewport[2];
    tgaHeader.height = iViewport[3];
    tgaHeader.bits = 24;
    tgaHeader.descriptor = 0;

    // ָ˺Сֽ˳ֽڱ任
#ifdef __APPLE__
    LITTLE_ENDIAN_WORD(&amp;tgaHeader.colorMapStart);
    LITTLE_ENDIAN_WORD(&amp;tgaHeader.colorMapLength);
    LITTLE_ENDIAN_WORD(&amp;tgaHeader.xstart);
    LITTLE_ENDIAN_WORD(&amp;tgaHeader.ystart);
    LITTLE_ENDIAN_WORD(&amp;tgaHeader.width);
    LITTLE_ENDIAN_WORD(&amp;tgaHeader.height);
#endif

    // ļ
    fopen_s(&amp;pFile, szFileName, "wb");
    if(pFile == NULL)
                {
        free(pBits);    
        return 0;
                }

    // дļͷ
    fwrite(&amp;tgaHeader, sizeof(TGAHEADER), 1, pFile);

    // дͼ
    fwrite(pBits, lImageSize, 1, pFile);

    // ͷʱرļ
    free(pBits);
    fclose(pFile);

    // ɹ
    return 1;
}
</pre>
<h2 id="toc_1.4"></h2>
<p>
	void glPixelZoom(GLfloat xfactor, GLfloat yfactor);<br />
<br />
</p>
<h2 id="toc_1.5">ת</h2>
<p>
	void glPixelTransferf(GLenum pname, GLfloat param);<br />
		scalebiasźƫתɫͨ. ӽɫɷֵ. ƫתֵӵɫɷֵ.<br />
		ֵ = (ֵ * ֵ) + ƫתֵ<br />
		ȱʡ, ֵΪ1.0, ƫתֵΪ0.0.<br />
<br />
</p>
<h2 id="toc_1.6">ڰģʽ</h2>
<p>
	ɫлɫͼ<br />
		glDrawPixels(iWidth, iHeight, eFormat, GL_UNSIGNED_BYTE, pImage);<br />
	һ, ÿصֵ<br />
		pModifiedBytes = (GLbyte*)malloc(iWidth * iHeight);<br />
	ȡֵ<br />
		glReadPixels(0, 0, iWidth, iHeight, GL_LUMINANCE, GL_UNSIGNED_BYTE, pModifiedBytes);<br />
	ֵдɫ<br />
		glDrawPixels(iWidth, iHeight, GL_LUMINANCE, GL_UNSIGNED_BYTE, pModifiedBytes);<br />
<br />
	ȱ: ȵļɫͨ.׳1.0, Ҫתģʽ.<br />
	NTSC׼<br />
		 = (0.3 * ɫ) + (0.59 * ɫ) + (0.11 * ɫ)<br />
<br />
</p>
<h2 id="toc_1.7">ɫӳ</h2>
<p>
	ڲһɫֵתΪһɫֵ.<br />
	ִɫ, ִgamma. ߲ͬɫʾʽ֮ת.<br />
	ӳ: glPixelTransferi(GL_MAP_COLOR, GL_TRUE);<br />
	ӳ<br />
		glPixelMapuiv(GLenum map, GLint mapsize, GLuint *value);<br />
		glPixelMapusv(GLenum map, GLint mapsize, GLushort *value);<br />
		glPixelMapfv(GLenum map, GLint mapsize, GLfloat *value);<br />
<br />
</p>
<h2 id="toc_1.8">ͼ"Ӽ"</h2>
<p>
	չ GL_ARB_imaging<br />
<br />
</p>
<pre c++>
///////////////////////////////////////////////////////////////////////////////
// This function determines if the named OpenGL Extension is supported
// Returns 1 or 0
int gltIsExtSupported(const char *extension)
{
        GLubyte *extensions = NULL;
        const GLubyte *start;
        GLubyte *where, *terminator;

        where = (GLubyte *) strchr(extension, ' ');
        if (where || *extension == '\0')
                return 0;

        extensions = (GLubyte *)glGetString(GL_EXTENSIONS);

        start = extensions;
        for (;;)
                {
                where = (GLubyte *) strstr((const char *) start, extension);

                if (!where)
                        break;

                terminator = where + strlen(extension);

                if (where == start || *(where - 1) == ' ')
                        {
                        if (*terminator == ' ' || *terminator == '\0')
                                return 1;
                        }
                start = terminator;
                }
        return 0;
}
</pre>
<p>
<br />
	ͼӼݹܷΪ3Ҫ: ɫɫ, Լ״ͼ.<br />
	ͼ: 챦P214<br />
<br />
</p>
<h3 id="toc_1.8.1">1. ɫ</h3>
<p>
	ɫֵɫʿռе, RGBɫΪXYZϵͳ. AlphaɷֿWɷ. ʵתΪһ4X4ɫ.<br />
	ɫľ(GL_PROJECTION, GL_MODELVIEW, GL_TEXTURE).<br />
	ͨglMatrixModeʹòGL_COLORɫΪ.<br />
</p>
<pre c++>
// ͼ
glMatrixMode(GL_COLOR);
glScalef(1.25f, 1.25f, 1.25f);
glMatrixMode(GL_MODELVIEW);

// Ϊȱʡֵ
glMatrixMode(GL_COLOR);
glLoadIdentity();
glMatrixMode(GL_MODELVIEW);
</pre>
<h3 id="toc_1.8.2">2. ɫ</h3>
<p>
	ָһɫֵı, 滻һصĵǰɫ.<br />
		void glColorSubTableEXT(GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid *data);<br />
			target: ָͼߵʲô׶Ӧɫ<br />
	ɫ GL_COLOR_TABLE<br />
		glGetCOlorTableParameterʹܹѯɫĸ<br />
<br />
	ɫԶɫɷֵӦӺƫɫ.<br />
	ʹglColorTableParameterʵ.<br />
<br />
	ɫΪɫԴݶɫȾ.<br />
		glCopyColorTable<br />
	ҲʹglColorSubTable滻ɫȫ򲿷.<br />
	glCopyColorSubTable滻ɫһɫȫ򲿷.<br />
<br />
</p>
<h2 id="toc_1.9"></h2>
<p>
	һֹ, һЩȨģʽ(Ϊ)һͼнش.<br />
	ԼڽصļȨƽֵ滻. ÿصɫֵݺеȨֵ.<br />
		 챦218<br />
	ڵ, ƺǸֵľ, ʾͼһӦȨ.<br />
</p>
<pre c++>
static GLfloat mSharpen[3][3] = {
{0.0f, -1.0f, 0.0f},
{-1.0f, 5.0f, -1.0f},
{0.0f, -1.0f, 0.0f} };
</pre>
<p>
	ΪӦûƹ, <br />
	glConvolutionFilter2D<br />
	glEnable(GL_CONVOLUTION_2D)<br />
<br />
</p>
<h2 id="toc_1.10">״ͼ</h2>
<p>
	glHistogram
	ռ״ͼ
	glGetHistogram
</p>

    </div>
</body>
</html>
