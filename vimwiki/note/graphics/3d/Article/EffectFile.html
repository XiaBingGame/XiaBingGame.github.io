<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<link rel="Stylesheet" type="text/css" href="../../../../style.css">
<title>EffectFile</title>
<meta http-equiv="Content-Type" content="text/html; charset=cp936">
</head>
<body>

<p>
NVIDIA's FX Composer 2 effects system
DirectX 9 HLSL effect file
一个 Gooch shading 的简单实现
</p>
<ul>
<li>
Gooch shading 的一部分是用表面法线和光源的位置进行比较. 如果法线朝向光源, 则使用 warm tone 着色, 否则使用 cool tone.

<li>
在两个用户定义的颜色进行插值. 这是non-photorealistic 渲染的一种形式.

<li>
Effect 变量定义于文件的开头部分, 关于相机位置的参数会自动跟踪.
<pre>
		float4x4 WorldXf	: World;
		float4x4 WorldITXf	: WorldInverseTranspose;
		float4x4 WvpXf		: WorldViewProjection;
</pre>

<li>
语法形式为 type id : semantic

<li>
float4x4为用户定义, 用于矩阵. id 则是内置名称. WorldXf 是模型至世界转换矩阵, WorldITXf 则是前者矩阵的逆矩阵. WvpXf 为模型空间至相机裁剪空间的矩阵, 这些值由应用程序提供, 不显示于用户接口

<li>
用户定义变量
<pre c++>
		float3 Lamp0Pos : Position &lt;
			string Object = "PointLight0";
			string UIName = "Lamp 0 Position";
			string Space = "World";
		&gt; = {-0.5f, 2.0f, 1.25f};
		float3 WarmColor &lt;
			string UIName = "Gooch Warm Tone";
			string UIWidget = "Color";
		&gt; = {1.3f, 0.9f, 0.15f}
		float3 CoolColor &lt;
			string UIName = "Gooch Cool Tone";
			string UIWidget = "Color";
		&gt; = {0.05f, 0.05f, 0.6f}
</pre>

<li>
尖括号内为注释. 大括号内为缺省值, 注释对于effect或shader编译器无效果, 但可被应用程序查询. 描述如何在用户接口内显示这些变量	

<li>
用于shader输入和输出的数据结构定义
<pre c++>
		struct appdata {
			float3 Position	: POSITION;
			float3 Normal	: NORMAL;
		};
		struct vertexOutput {
			float4 HPosition	: POSITION;
			float3 LightVec		: TEXCOORD1;
			float3 WorldNormal	: TEXCOORD2;
		};
</pre>

<li>
appdata定义模型上每个顶点上的数据, 用于vetex shader的输入. vertexOutput 则是vertex shader的输出和pixel shader的输入.

<li>
vertex shader 程序如下:
<pre c++>
		vertexOutput std_VS(appdata IN){
			vertexOutput OUT;
			float4 No = float4(IN.Normal, 0);
			OUT.WorldNormal = mul(No, WorldITXf).xyz;
			float4 Po = float4(IN.Position, 1);
			float4 pW = mul(Po, WorldXf);
			OUT.LightVec = (Lamp0Pos - Pw.xyz);
			OUT HPosition = mul(Po, WvpXf);
			return OUT;
		}
</pre>

<li>
pixel shader 程序如下
<pre c++>
		float4 gooch_PS(vertexOutput IN) : COLOR
		{
			float3 Ln = normalize(IN.LightVec);
			float3 Nn = normalize(IN.WorldNormal);
			float ldn = dot(Ln, Nn);
			float mixer = 0.5 * (ldn + 1.0);
			float4 result = lerp(CoolColor, WarmColor, mixer);
			return result;
		}
</pre>

<li>
一个 effect 文件可以有一些函数组成, 也可包括其他 effects 文件的函数

<li>
一个通道pass由一个vertex和一个pixel shader 组成, 以及一些用于该通道的状态设置. 一个技术technique则有一个或多个passes产生想要的效果.下面的文件则有一个technique, 该technique有一个pass
<pre c++>
		technique Gooch &lt;string Script = "Pass=p0;";&gt;{
			pass p0 &lt;string Script = "Draw=geometry;";&gt;{
				VertexShader = compile vs_2_0 std_VS();
				PixelShader = compile ps_2_a gooch_PS();
				ZEnable = true;
				ZWriteEnable = true;
				ZFunc = LessEqual;
				AlphaBlendEnable = false;
			}
		}
</pre>

<li>
多个 technique 可存储于相同的effect文件.用于不同的shader model(SM2.0, SM3.0等)

<li>
一个effect包装了相关的techniques, 一系列的方法已发展出来用于管理一系列shaders.

</ul>

</body>
</html>
