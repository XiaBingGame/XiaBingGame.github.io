<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<link rel="Stylesheet" type="text/css" href="../../../../../style.css">
<title>RealTimeRendering17</title>
<meta http-equiv="Content-Type" content="text/html; charset=cp936">
</head>
<body>

<h1 id="toc_1">Chapter 17 Collision Detection</h1>
<ul>
<li>
Collision detection(CD)为许多计算机图形应用程序的基础和重要组成部分. CD在以下领域中扮演重要的角色, 其包括虚拟制造, CAD/CAM, 计算动画, 基于物理地建模, 游戏, 飞行和交通模拟器, 机器人学, 路径和运动规划(tolerance verification), 组装(assembly), 以及几乎所有的虚拟现实模拟.

<li>
碰撞检测为collision handling的一部分, collision handling可以划分为三个主要部分: collision detection, collision determination, collision response. collision detection的结果为一个布尔值, 表示两个物体是否碰撞. collision determination则查找两个物体间实际的相交类型. 最后, collision response 则确定在两个物体的碰撞之后应当作出什么反应动作. 

<li>
在章节17.1里, 我们讨论一个简单且极端快的碰撞检测技术. 其主要思路为使用一个线条的集合近似模拟一个复杂的物体. 这些线条用于与环境的图元的相交测试. 这个技术常用于游戏. 另一个近似地方法见章节17.2的描述, 使用环境的一个BSP树表示, 以及可能使用一个圆柱体描述一个角色(character). 然而, 所有的物体不能永远使用线条或者圆柱体来近似模拟, 一些应用可能需要更精确地测试. 

<li>
想象, 例如, 我们想要确定一个三维的手和一个三维的一杯茶是否碰撞, 所有的物体都是用三角形表示. 如何有效率的完成这个? 确定地, 手的每个三角形可以与茶杯的每个三角形进行相交测试(章节16.11). 但是在这个情况下, 两个物体相距多远, 一个算法应当能快速地报告, 不可能用这个详尽的测试. 即使当物体靠近在一起, 详尽的测试也是没有效率的. 这里有需要快速地处理这样的情况, 也很容易考虑复杂场景的碰撞检测, 以及可见图17.1中的例子. 

<li>
章节17.3为处理一个通用的层次体系的围绕体碰撞算法, 基于OBB的一个特别实现在章节17.4中介绍. 接下来的特点(features)为大多数CD系统所所希望有的特性(characteristics).

<ul>
<li>
当模型由大量数量的多边形组成, 且模型之间相距很远时以及模型之间相距很近时, 它们都能达到交互的频率.

<li>
它们还能处理polygon soups. 也就是没有类似凸性(convexity)或者可用相邻信息的限制的通用多边形模型. 

<li>
该模型可以经历刚体运动, 也就是旋转加上平移, 乃至更通用的变形类型.

<li>
它们提供有效率的bounding volume(BVs), 它们则试图创建用于紧贴一系列几何体的volume. 小的BVs改进确定两个物体是否碰撞的算法的性能. 该BV的创建应当快速的.

</ul>
<li>
由于一个场景可能包含数十或数百移动的物体, 一个好的CD系统也要能够处理这样的情况. 如果这个场景包含n个移动的物体和m个静止的物体, 则有一个自然的方法要执行

<ul>
<li>
公式 17.1

<li>


</ul>
<li>
对于每帧的物体测试, 公式的第一个部分表示静止物体与运动物体之间的测试数量, 以及最后一个部分表示运动物体相互之间测试的数量. 这个原生的方法随着m和n增加而变得昂贵. 这种情况需要更聪明的方法, 这个为章节17.5的主题. 类似的一个方法典型使用一个算法首先探测物体与物体的碰撞, 其被分解使用. 例如, 来自章节17.4的OBBTree算法.

<li>
在讨论了层次分层的碰撞探测, 简略地细目继续一些不同的各种主题.  Time-critical collision detection为在常量时间内完成近似碰撞的技术. 以及在17.6.1中有介绍. 有时要求两个物体间的最短距离, 以及接下来介绍这个课题, 以及用于变形物体的碰撞检测上的研究. 最后, 简单的讲述collosion response.

<li>
必须指出性能在CD的情况下很难估计.这是由于算法对实际的碰撞场景为很敏感的, 以及没有算法可以在所有情况下都执行得最好.

</ul>

<h2 id="toc_1.1">17.1 Collision Detection with Rays</h2>
<ul>
<li>
在本章节中, 我们介绍一个在确定环境下工作运作非常好的技术. 想象一辆车在倾斜的路面上向上行驶, 以及我们想要关于该路线的信息(也就是构建道路的图元)以便向上行驶该车. 其可以通过测试所有车轮的所有图元与道路的所有图元来完成. 在车的这个情况中, 我们可以在每个车轮上放置一个ray(见图17.2), 这个近似模拟实际上工作的非常好. 只要我们可以假设四个车轮为车辆仅有的可以与环境(该道路)接触的部分. 假设车辆停在起始的位置, 在车轮上放置ray, 以便ray的原点位于车轮与坏境接触的地方. 车轮上的ray则再次进行与环境的相交测试, 如果从ray原点到环境的距离为0, 则该车轮在地面上. 如果距离大于0, 则该车轮不合环境相接触, 如果为负的距离, 则意味着车轮刺入环境中. 该应用程序可以使用这些距离计算collision response---一个负值可以向上移动该车(在那个车轮上), 一个正值距离可以向下移动该车(除非该车在空中短时间飞跃). 注意这个类型的技术可以修改以适应更复杂的场景. 如果该车碰撞, 则有旋转运动中的集合, 需要更多不同方向中的ray.

<li>
为了加速相交测试, 我可以使用常用于在计算机图形中加速的相同技术---层次地表达. 环境可用轴对齐的BSP树(本质上与 k-d 树相同)表示. BSP树可在章节14.1.2中发表, 他们可用于view frustum culling算法, BSP树还可用于加速相交测试. 根据环境中使用的哪些图元, 需要不同的 ray-object相交测试方法(见第16章). 一个BSP树不是仅有的可用于快速查找相交的表达---例如, 也可使用一个bounding volume hierarchy.

<li>
不同于标准的 ray tracing, 我们需要在ray之前的最近的物体, 其为沿着该ray最远向后的相交点, 且看有负的距离. 为了避免处理该ray时在两个方向中查找, 该测试ray的原点本质上向后移动直到在围绕环境的bounding box之外, 此时再次与环境进行测试. 实际上, 即为ray不再从距离0上开始, 而是在一个负值上开始, 这样可以让其在box之外. 为了处理更通用的设置, 类似驾驶一辆车通过隧道以及探测与顶部的碰撞, 其应当在所有方向上查找.

</ul>

<h2 id="toc_1.2">17.2 Dynamic CD using BSP Trees</h2>
<ul>
<li>
这里, 由Melax[854, 855]发表的碰撞检测算法, 其确定由BSP树(见章节14.1.2)描述的几何体之间的碰撞, 以及collider可为球体, 圆柱体, 或者物体上的一个凸包. 其还允许dynamic collision detection. 例如, 当一个球体从帧n时的位置P0移动到帧n+1时的位置P1, 当在P0到P1的直线路径上发生碰撞, 该算法可以检测出来. 这个发表的算法可用于商业游戏, 其角色的几何体近似模拟为一个圆柱体.

<li>
可以非常有效率的测试标准BSP树与线段. 一个线段可以表示为从点P0移动到P1的点(粒子). 也许有数个相交, 但第一个相交表示点与BSP树中所表示几何体之间的碰撞. 注意, 这种情况下, BSP树为surface-aligned, 而不是axis-aligned. 即为, 树中的每个平面与场景中墙壁, 地板, 天花板一致. 其可以轻易地扩充为处理一个半径为r的球体, 其从P0移动到P1, 这个替代了前面一个点的移动. 不再测试一个线段与BSP树节点中的平面, 每个平面沿着平面法线移动r个距离(见16.18的类似方法). 这种类型的平面修正见图17.3中的诠释. 其在每个collision query中即时地完成, 这样一个BSP树可以用于任意大小的球体. 假设一个平面为π: n・x + d = 0, 修正平面则为π': n・x + d ±r = 0.  r的符号依赖于在碰撞的查找中平面的哪一边你想要继续测试/遍历. 假设角色在平面正的半空间内, 也就是 n・x + d &gt;= 0. 我们应当从d中减去半径r. 注意其负的半空间则被看为"solid". 也就是角色不能步行通过的地方.

<li>
一个球体不能够很好的在游戏中近似模拟一个角色(Schroeder提出几个球体则可运作的很好[1137]). 角色顶点的convex hull或者围绕一个角色的圆柱体则可以做更好的工作. 为了使用其他的围绕体, 则需要有差别地修改平面公式中的d. 为了测试一个点集合S的convex hull与一个BSP树的碰撞, 公式17.2中的标量值可以加进平面公式中的d值中[854].

<ul>
<li>


<li>


</ul>
<li>
负号, 其假设角色位于平面的半空间内. 点P0为所发现合适的参考点, 对于一个球体, 默认选择球心. 对于一个角色, 可能选择靠近脚的点, 或者肚脐上的点. 有时这个选择可简化公式. 点P0与BSP树进行测试, 对于一个dynamic query, 在一帧内, 其从一个点移动到另一个点, 点P0用于当作线段的起点, 假设角色在一帧内按向量w移动, 则线段终点为 P1 = P0 + w. 

<li>
圆柱体则更有用, 这是由于其可更快地测试以及在游行中相当好地近似模拟一个角色. 然而修正平面公式的值其推导则更复杂. 对于该算法, 我们通常所做的为重算围绕体(球体, convex hull, 圆柱体)与BSP树的测试为一个点P0与修正BSP树的测试. 其基本与Minkowski sums(见章节16.18.3和17.6.2)相同. 此时, 则扩展其为一个移动的物体, 点P0则被替换为从P0目标点P1的线段. 

<li>
我们推倒这样的测试用于一个圆柱体, 其性质可见图17.4的左部分. 参考点为P0, 在圆柱底的中心. 图17.4(b)则为我们想要求解的, 测试圆柱体与平面π. 在图17.4(c)中, 我们移动平面π使得其几乎靠近圆柱体, 此时得到P0到平面的距离e, 该距离e则用于图17.4(d)移动平面π到新的位置π'. 此时, 该测试简化为测试点P0与π'. 该e值对于每帧每个平面即时地计算出来. 实际上, 首先计算P0到点t的向量, t为移动的平面接触该圆柱体的点. 可见图17.4(c). 接下来可用下面的公式计算e:

<ul>
<li>
公式17.3

<li>


</ul>
<li>
接下来就是要求解除t. t的z成员(圆柱为轴对齐的)求解很简单. 如果Nz &gt; 0, 则Tz = P0z, 即为P0的z成员. 否则, Tz = P0z + h. (这里z轴为圆柱的轴). 如果Nx和Ny都为0(例如, 地板或天花板), 则我们可以用椭圆帽上的任意一点. 一般的选择为 (Tx, Ty) = (Px, Py), 圆柱帽的中心. 其他情况, 如果该n不垂直的, 接下来的选择则给出了圆柱帽边缘的一点.

<ul>
<li>
公式17.4

<li>


<li>


<li>


<li>


</ul>
<li>
其投影平面法线值xy平面, 而后乘以r以位于圆柱的边上.

<li>
使用这个方法会发生不精确的内容. 可见图17.5中的一个例子. 正如所见, 其可通过引入额外的斜平面来解决该问题. 实际上, 计算两个相邻平面之间的"outer"angle(外角). 如果该角大于90度, 则插入该额外的平面. 其思路为改进该近似模拟, 该角应当为一个圆角. 在图17.6中, 可以见到一个普通的BSP树和一个增加了斜平面的BSP树之间的区别. 该斜的平面必定改进了精确度, 但是其并没有移除所有的错误. 

<li>
接下来为碰撞检测算法的伪代码, 其有 root N of the BSP tree, 其孩子为N个负孩子和N个正孩子, 以及由p0和p1定义该线段, 注意, 在全局变量Pimpact中返回碰撞的点(如果存在). 

<li>
如果到达一个叶子且到达一个实心的(solid)一边时, 则函数 isSolidCell 返回真. 见图17.3对实心cell和空cell的诠释. 当线段(由移动路径V0和V1所定义)的一部分位于节点移动的(sh)平面之内时函数clipLineInside返回为真.即位于负的半空间中. 其还clip线条与节点的shifted平面, 以及返回一个结果的线段W0和W1. 函数clipLineOutside则类似, 注意, clipLineInside和clipLineOutSide返回的线段也相互重叠. 原因可见图17.7, 以及如何clip一个线条. 行9设置V1 = Pimpact, 以及其为简单的一个最优化. 如果发现一个hit, 则一个潜在的碰撞点, Pimpact, 则此时没有该点之外的内容需要测试, 这是我们想要碰撞的第一个点. 在行7和行11上, N移动(shifted)"out"相对于"in", 这些shift涉及到前面推导的用于球,convex hull, 以及圆柱体的修正平面公式.

<li>
Melax显示了该算法比其他不使用动态修正平面的算法昂贵2.5倍到3.5倍. 该方案的优点为仅有一个BSP树需要用于测试所有的角色以及物体. 另外的选择为存储不同的BSP树用于每个不同半径和物体类型.

</ul>

<h2 id="toc_1.3">17.3 General Hierarchical Collision Detection</h2>
<ul>
<li>
本章节介绍一些通用的思路和方法用于在碰撞检测算法中检测两个给定模型之间的碰撞. 这些算法有页面794所介绍的4个特点. 这些算法的通常denominators为:

<ul>
<li>
他们使用围绕体构建每个模型层次地表达.

<li>
用于碰撞query的高层代码都是类似的, 而无需考虑正使用的BV类型.

<li>
一个简单的cost函数可用于trim, evaluate, 以及比较性能. 

</ul>
</ul>

<h3 id="toc_1.3.1">17.3.1 Hierarchy Building</h3>
<ul>
<li>
初始地, 一个模型由大量数目的图元表示, 在我们的例子中其为polygon soup, 其所有多余三个顶点的多边形分解为三角形(见章节12.2). 此时, 由于每个模型应当由某种类型bounding volume的一个层次体系表示. 则必须开发一个方法构建带有所需性质的类似层次体系. 一个常用于碰撞检测算法的层次体系为一个称之为 k-ary树的数据结构. 其每个节点许有最多k个孩子(见章节14.1), 许多算法使用k-ary树的最简单实例---二叉树, 其k=2. 在每个内部节点上, 则有一个BV封装其体内所有的孩子, 以及在每个叶子上有一个或多个图元(在我们的例子中则为三角形). 任意节点A的围绕体(无论是内部节点还是叶子), 记为A[BV], BV为下标, 属于A的孩子集合记为A[c], 下标为c.

<li>
三个构建层次体系的主要方法: 一个bottom-up方法, 一个incremental tree-insertio方法, 一个top-down方法. 为了创建有效率的紧贴的结构, 通常该BV的区域(area)或volume尽可能地最小化[63, 417, 672, 966]. 对于CD, 更需要最小化volume, 这是由于一个BV与其他的BV相测试. 对于第一个方法, bottom-up, 开始组合一些图元, 以及查找它们的BV, 这些图元应当紧靠在一起, 这个可以使用这些图元间的距离来确定. 此时, 或以相同的方式创建新的BVs, 或者已有BVs可以和其他以类似方式构造的一个或多个BVs分组在一起, 而后产生一个新的, 更大的父BV. 重复这个过程直到只有一个BV存在, 其则成为该层次体系的根节点. 以这种方式, 位置靠近地图元永远在bounding volume hierarchy中相互靠近在一起. Barequet发表了BOXTREE[63], 一个用于执行ray tracing和碰撞检测的数据结构, 该树就是从底向上构建.

<li>
该 incremental tree-insertion方法开始于一个空树, 此时所有的图元和它们的BV一次一个添加到该树中. 其可见图17.8的图解. 为了构造一个有效率的树, 必须发现树中的插入点. 选择的该点可使得整个树的volume增长最小. 一个简单的方法为向下至孩子节点, 其给予树中一个更小的增长. 这种类型的算法时间为O(n logn). 随机化图元插入的次序可以改进树的形成[417]. 对于更复杂的方法, 可见Omohundro的著作[966]. 其关于碰撞检测上下文中的incremental tree-insertion很少, 但是其在ray tracing和intersection queries中有一个好的结果[417], 所以其对于碰撞检测可能也工作得很好.

<li>
top-down方法, 其为层次构造算法的主要方法. 其开始于查找该模型所有图元的一个BV, 而后作为该树的根节点. 而后应用一个divide-and-conquer策略, 首先BV被分割成k或者更少的部分. 对于每个这样的部分, 发现其所有包含的图元, 而后以和根节点一样的方式创建一个BV. 也就是, 递归地创建该层次体系. 最常用的为发现图元应当被划分的某些轴. 以及发现该轴上一个好的分割点. 在章节16.4中讨论了一个几何的可能性, 以及其可用于查找一个好的分割点, 其可导致更好的BVHs.该top-down方法的一个潜在优点其可创建该层次体系lazily. 也就是, 根据需要的原则创建.(an as-needed basis). 即意味着, 我们构造的层次体系只用于那些场景实际需要的部分. 但是由于其在运行时期执行该构建进程, 无论何时创建层次体系的一部分, 其性能会有显著的下降. 这对于类似实时要求的游戏应用程序是不可接受的. 但对于CAD应用程序或者离线计算路径规划, 动画或者其他时可以节省大量的时间和内存.

<li>
对于CD算法的一个挑战为查找一个紧贴适应的围绕体和层次构造方法可创建平衡的有效率的树. 平衡树到所有的叶子几乎相同的时间, 所以collision query的时间不会根据叶子的访问而变化, 这并不意味着其对于所有的输入都是最好的, 例如一个模型的一部分很少或者从来不被query用于一个碰撞, 则这些部分可位于一个不平衡树深的地方. 最常被query的部分则常靠近与根节点[434]. 这个用于一个OBB树的程序(procedure)细节可见页面809的描述.

<li>
注意在章节14.1中描述了加速算法的相关空间数据结构, 以及章节16.3中对BV创建的处理.

</ul>

<h3 id="toc_1.3.2">17.3.2 Collision Testing between Hierarchies</h3>
<ul>
<li>
通常我们想要在不同时间检测两个不同的状况. 第一个, 我们可能只关注两个模型是否碰撞, 以及当发现两个三角形重合之时, 终止该方法. 第二个, 我们可能想要报告所有重合的三角形. 第一个问题的解决称之为collision detection, 第二个问题的解决称之为collision determination. 接下来的伪代码用于解决第一个问题, 以及修改部分代码则可以解决第二个问题.

<li>
A和B为模型层次体系中的两个点, 最初其为模型的根节点. A[BV]和B[BV](这里BV为下标)用于访问恰当节点的BV, 回忆A[c]为A的孩子节点集合, 以及T[A]用于标记为叶子节点的三角形(伪代码中, 假设每个节点只有一个三角形). 其基本思路为, 当重合被检测到时, 打开一个(该更大的)box以及递归测试它的内容.

<li>
正如伪代码所见, 代码部分可以共享. 像这个发表的显示了算法如何工作. 有些行应当关注, 行1-2则注意两个节点都是叶子的情况, 行3-10则处理节点都为内部节点的情况. Volume(A) &gt; Volume(B)的比较结果为有最大volume的节点向下移动. 类似一个测试其背后的思路为对于调用FindFirstHitCD(A, B)和FindFirstCD(B, A)其有相同的树遍历, 所以遍历则变成确定性的. 如果第一个碰撞检测有一个特殊的状态(early on, collision response, etc)则其为很重要的. 也许更重要的为其趋向于更出更好的性能, 当在每一步中首先遍历的是最大的box. 另一个思路则为在A和B之间交替向下移动. 由于其避免了volume的计算, 则可以更快些. 或者, 对于刚体可以预计算volume, 但是其每个节点要求额外的内存. 同样, 对于许多BV不需要计算其实际的volume, 计算保存"volume order"则已足够. 作为一个例子, 对于球体计算其半径则已足够.

<li>
为了发现所有碰撞的三角形对, 则需要修改伪代码, 算法中发现的三角形对存储在全局列表L中, 初始其为空的, 行2需要修改, 如果测试通过, 程序添加该三角形对到L(不再返回). 当递归结束, 则所有的碰撞在L中.

</ul>

<h3 id="toc_1.3.3">17.3.3 Cost Function</h3>
<ul>
<li>
公式17.7中的t作为估计层次的BV结构在用于ray tracing加速算法上下文中的性能估计[1336]. 其还可用于估计CD算法的性能[433]. 其还可通过公式最后一个部分增加新的代价细节[672, 699]. 其可能对性能有显著影响. 代价结果来自如下, 如当一个模型经历一个刚体运动, 则它的BV以及部分或所有的层次都可能需要重新计算, 这点依赖于运动以及BV的选择. 

<ul>
<li>
公式 17.7

<li>


</ul>
<li>
这里, 参数为:

<ul>
<li>
n[v]: BV/BV重合测试的数量

<li>
c[v]: 一个BV/BV重合测试的代价

<li>
n[p]: 用于重合测试的图元对数量

<li>
c[p]: 测试当两个图元是否重合的代价

<li>
n[u]: 因为模型运动该BV更新的数量

<li>
c[u]: 更新一个BV的代价.

</ul>
<li>
创建更好的一个模型层次体系分解可有更低的n[v], n[p]和n[u]值. 创建一个更好的方法用于确定是否两个BV或者两个三角形重合可有更低的c[v]和c[p]. 然而这些常为互相冲突的目标, 这是因为改变BV的类型以便用于更快地重合测试则会导致得到更宽松适应(looser-fitting)的volume.

<li>
在过去使用的不同围绕体例子为球体[572], 轴对齐围绕盒(AABBs)[537, 1290], 有向围绕盒(OBBs)[433], k-DOPs(discrete oriented polytopes)[672, 686, 1399], pie slices[63], spherical shell[699, 700](其很好地适应了Bezier patches). line swept spheres(LSSs), rectangle swept spheres(RSSs)[730], 以及QuOSPOs(其组合了OBBs和k-DOPs的优点)[514]. 球体其变换和重合测试最快, 但是提供了一个对物体贫瘠的适应. AABBs提供了更好的适应以及快速的重合测试, 当模型中有大量数量的轴对齐的几何体(正如大多数建筑模型的例子), AABBs为一个好的选择. OBBs则有好得多的适应性, 但是其重合测试更慢. k-DOPs的适应性则由参数k确定, 更高的k值有更好的适应性, 更慢的重合测试, 更低劣的变换速度. 对于k-DOPTree的更多信息, 可参考Klosowski的著作[538, 672, 673].

</ul>

<h2 id="toc_1.4">17.4 OBBTrees</h2>
<ul>
<li>
设计的OBBTrees在当parallel close proximity时执行得特别好, parallel close proximity为在碰撞检测中发现两个surface非常靠近且近乎平行. 这种类型的状况常发生在tolerance analysis和virtual prototyping中. 

</ul>

<h3 id="toc_1.4.1">Choiceof Bounding Volume</h3>
<ul>
<li>
正如OBBTree算法名字所提示的, 其围绕体使用OBB. 这是因为AABB和球体不能给出很好的适应性. 另一个原因则是Gottschalk开发了一个新的方法用于确定两个OBBs是否重合. 这个方法在量级上比之前的方法更快. 这个测试速度主要因为变换OBBs使得其中一个成为中心位于原点的AABB. 这个实际的变换花费了63个操作, 以及OBB/OBB测试因为15个轴测试中的一个而在初期退出,以及最后一个轴测试之后的退出可能花费180个操作. OBB/OBB的重合测试的处理可见章节16.13.5.

<li>
章节17.3.3上的性能估计框架的部分里, 因为之前的原因OBBs其n[v]和n[p]比AABBs和球体的更低.

<li>
Van den Bergen则建议了一个简单的技术用于加速两个OBBs间的overlap测试[1290, 1292]: 简单地掠过最后九个轴测试, 这些轴为垂直于第一个OBB边和第二个OBB边的的方向. 这个测试常涉及为SAT lit. 几何上其可看成执行两个AABB/AABB测试, 第一个测试在第一个OBB的坐标系统中执行, 第二个测试则在另一个OBB坐标系统中执行. 可见图17.9的图解. 该变短的OBB/OBB测试有时会报告两个不相连的OBBs为重合的. 有些情况下, OBBTree的递归会比所需要的更深. Van den Bergen的技术在叫SOLID的碰撞检测包中实现[1290, 1291, 1292, 1294], 其还可处理可变形的物体.

</ul>

<h3 id="toc_1.4.2">Hierarchy Building</h3>
<ul>
<li>
基本数据结构为一个二叉树, 其内部节点保存一个OBB, 外部节点(叶子)则仅保存一个三角形. Gottschalk开发的top-down方法用于创建该层次体系, 其划分以查找紧贴适应的OBB用于一个polygon soup以及沿着该OBB的一个轴分割, 其还可将三角形分为两组, 每一组的三角形, 可以计算一个新的OBB. 该OBBs的创建可见章节16.3.

<li>
在我们计算用于一个三角形集的OBB之后, 其volumes和三角形应当分割和形成两个新的OBBs. Gottschalk使用一个策略, 其取box最长的轴而后将其分割成相同长度的两个部分. 该伪代码的诠释可见图17.10. 一个包含box中心的平面, 以及有最长的box轴用于用于其法线划分该三角形为两个子组. 穿过该平面的三角形分配到包含其中心的一组. 如果最长的轴不能子划分(稀少的情况---所有三角形的中心位于划分的平面上或者所有的中心位于分割平面的一边), 则按照减少的顺序, 尝试其他的轴.

<li>
对于每个子组, 章节16.3中介绍的方法用于计算(子)OBBs, 如果该OBB在中线中心点被替代分割, 则得到一个平衡树.

<li>
由于convex hull的计算时间花费了 0(n logn)以及二叉树的深度为O(logn), 用于创建一个OBBTree的总运行时间为O(nlognlogn).(里面为logn的平方, 打印不好写, 注意).

</ul>

<h3 id="toc_1.4.3">Handling Rigid-Body Motions</h3>
<ul>
<li>
在OBBTree层次体系中, 每个OBB, A与一个刚体变换(一个旋转矩阵R和一个移动向量t)M[A]一起存储. 该矩阵保存了OBB相对对其父OBB的方位和位置.

<li>
现在, 假设我们开始测试两个OBBs, A和B. 在其中一个OBBs中的坐标系统中执行A与B之间的重合测试. 现在, 假设我们确定在A的坐标系统中执行测试, 这种方式下, A为一个AABB, 其中心为原点. 其思路为变换B到A的坐标系空间中, 通过下面的矩阵完成, 首先变换B到其自己的位置和方位, 而后变换至A的坐标系空间中. 有公式:

<ul>
<li>
公式 17.9

<li>


</ul>
<li>
该OBB/OBB重合测试采用由一个3x3旋转矩阵R和一个平移向量t组成的矩阵作为输入, 其有相对于A的B的方位和位置(见章节16.13.5). 所以T[AB]被分解为如下:

<ul>
<li>
公式 17.10

<li>


</ul>
<li>
现在假设A与B重合, 则我们向下至A的孩子C, 一个聪明的技术用于完成这个, 我们在C的坐标系统中执行测试, 而后思路为变换B至A的坐标系统中(用T[AB])以及变换至C的坐标系统中(使用M[C]的逆矩阵). 这通过之后的矩阵完成, 其可用于OBB/OBB重合测试的输入:

<ul>
<li>
公式17.11

<li>


</ul>
<li>
这个程序被递归使用用于测试所有的OBBs.

</ul>

<h3 id="toc_1.4.4">Miscellaneous</h3>
<ul>
<li>
该FindFirstHitCD(伪代码)用于两个层次树的碰撞检测, 在章节17.3.2所介绍的, 其可用于之前算法所介绍的树. 只是需要变换的是overlap()函数, 其应指向用于测试两个OBBs重合的测试程序.

<li>
所有在OBBTree中涉及到的算法在一个免费软件包RAPID(Robust and Accurate Polygon Interference Detection)[433]中实现.

</ul>

<h2 id="toc_1.5">17.5 A Multiple Objects CD System</h2>
<ul>
<li>
这里我们讨论一个两层(two-level)的碰撞检测系统[181, 574, 775], 其目标为大尺度的环境下运动的多个物体. 该系统的第一层报告该环境中所有物体的潜在碰撞, 其结果发送给第二层, 第二层在每对物体间执行精确地碰撞检测. 来自17.4的OBBTree算法(或者其他两个物体间的检测碰撞方法)可用于这个任务.

</ul>

<h3 id="toc_1.5.1">17.5.1 Broad Phase Collision Detection</h3>
<ul>
<li>
尽可能报告少的潜在物体之间的碰撞. 其在更高层(也就是物体层中)中执行测试, 因此其常被称为broad phase collision detection.

<li>
大多数算法通过在一个BV中封装每个物体开始, 以及而后应用一些技术查找所有重合的BV/BV对. 一个简单的方法为对于每个物体使用AABB, 为了避免重计算一个经历了刚体运动的物体的AABB, 该AABB应当修正为一个fixed cube, 其足够大到包含任意方位的该物体. 这个fixed cubes可以用于快速地确定哪些物体对在这些围绕体下完全地不相连. 有时使用dynamically resized AABBs更好一些.

<li>
不使用fixed cubes, 则可使用球体, 其可以完美封装任意方位下的该物体. Kim[656]则介绍了球体的一个算法. 还有另一个方法用于convex hull或其他的凸多面体, 其使用Lin-Canny算法[773, 774]或V-clip算法[870]的例子了来代替fixed cubes. 这里有两个算法用于broad phase CD:sweep-and-prune, 还有使用grids. 以及还有章节14.1.3中介少的用于loose octree的完全不同的方法.

</ul>

<h4 id="toc_1.5.1.1">Sweep-and-Prune</h4>
<ul>
<li>
我们假设每个物体有一个封闭的AABB, 在sweep-and-prune技术中[60, 774, 1363], 可利用temporal coherence(其常用语典型的应用中). temporal coherence意味着在帧到帧之间物体在位置和方位上经历了相对小(如果存在)的变化(所以其也可称为frame-to-frame coherence).

<li>
Lin[774]指出三维中的重合bounding box问题可在O(n lognlogn + k)时间内解决(k为成对的重合数量), 但是其可利用coherent来改进, 其时间可减少为O(n+k), 这个假设动画(animation)有相当数量的temporal coherence.

<li>
如果两个AABBs重合, 则所有三个一维的interval(由AABB的起点和终点形成)在每个主要轴方向上必须重合. 这里, 当frame-to-frame coherency很高时(在合理的应用程序中可以期待的), 如何可以有效率地检测许多一维interval的所有重合. 则有这样的解决方案, 用于AABB的三维问题则可使用三个主要轴的一维算法来解决.

<li>
假设有n个interval(沿着一个特定的轴)由s[i]和e[i]表示, 其中, s[i] &lt; e[i], 以及 0 &lt;= i &lt; n. 这些值以增序在一列表中排序. 当遇到一个起点s[i], 则该对应的interval放入活跃interval列表, 当遇到一个终点, 则对应的interval则从活跃列表中移除. 现在, 遇到如果一个interval的起点, 则该interval和所有在活跃列表中的interval重合. 具体可见图17.11.

<li>
这个程序可用O(nlogn)排序所有的interval, 加上O(n)时间扫过该列表以及O(k)时间报告所有重合的interval. 其结果为 O(nlogn + k)算法. 然而, 由于temporal coherence, 该列表不会在帧到帧的过程中变化很大, 所以bubble sort或者 insertion sort[676]可用于在第一个pass之后, 以有更大的效率. 这些排序算法排序接近排序好的列表, 其期待时间为O(n).

<li>
通过逐步建立排序的序列做插入排序工作. 我们开始列表中的第一个号, 如果我们仅考虑其入口, 则该列表已排序的. 接下来, 我们添加第二个入口. 如果第二个入口比第一个小, 则交换位置. 否则继续. 持续这样排序所有想要排序的物体, 其结果为已排序的列表. 

<li>
为了使用temporal coherence, 我们为每个interval对保存一个布尔值. 对于大模型, 可能这个不实际, 前暗指了O(n^2)的存储代价. 一个具体的布尔值TRUE为该对重合, FALSE为该对不重合. 当执行第一次排序时在算法的第一步中初始化布尔值. 假设在之前的帧一对interval重合, 所以它们的布尔值为TRUE, 如果一个interval的起点和其他interval的终点交换, 则该interval对的状态反转. 即布尔值为FALSE以及他们不再重合. 在其他方向上同样操作. 也就是, 如果布尔值为FALSE, 当一个起点与一个终点变换位置, 则变成TRUE, 可见图17.11的图解.

<li>
我们可以创建一个已排序的intervals列表用于所有三个主要轴, 以及使用之前的算法查找每个轴的重合intervals. 如果对于一对其所有的三个interval都重合, 则它们的AABBs(该interval所表示的)也重合. 否则它们不重合. 其期待时间为线性的, 为O(n+k), k为重合对的数量. 注意该算法可恶化至O(n的平方). 这个是当clumping发生的时候产生. 一个例子为大量的物体位于地板上, 如果z轴为地板的法线, 则我们在z轴上得到clumping. 一个解决方法为完全略过z轴, 只执行x轴和y轴上的测试[315], 在许多情况中, 这个工作得很好.

</ul>

<h4 id="toc_1.5.1.2">Grids</h4>
<ul>
<li>
grid和hierarchical grids不但可用于ray tracing, 还可用于broad phase collision detection[1275], 其最简单的形式中, 一个grid为一个覆盖整个场景空间不重合的grid cell的n维数组. 每个cell为一个box, 所有的box有相同的大小. 从一个高层中, 有grid的broad phase CD开始于插入我们场景中所有物体BV到grid中. 如果两个物体关联至相同的grid cell, 则我们立刻知道这两个物体的BV可能重合. 因此, 我们执行一个简单的BV/BV重合测试, 以及当它们碰撞, 我们可以开始CD系统的第二层. 对于图17.12的左图, 显示了有四个物体的二维grid.

<li>
为了得到好的性能, 选择一个合理的grid cell大小很重要. 这个问题可见图17.12的右图. 一个思路为发现场景中最大的物体, 而后使得grid cell大小大到足够刚好封装所有可能方位的该物体[315]. 这种方式下, 在三维grids情况下所有的物体则可能重合最多八个cells.

<li>
存储一个大的grid则可能相当浪费, 尤其如果grid显著的部分留下未用. 所以建议使用spatial hashing代替[315, 1261, 1275]. 通用的, 每个grid cell映射至hash表中的一个索引. 所有被一个grid cell重合的物体插入该hash表中, 以及可以和以往一样继续测试. 本段后面部分讲述不使用spatial hashing的缺点. 

<li>
对于整个grid, 相同的grid cell大小并不是最优化的. 因此, 我们可使用层次体系的grid. 使用不同cell大小的嵌套grids, 物体可以仅插入物体BV刚好小于其grid cell大小的grid. 当层次grid中相邻的levels之间的不同grid cell大小刚好两个, 则该结构非常类似于octree. 更多的内容可见Ericson关于该主题的解决[315].

</ul>

<h3 id="toc_1.5.2">17.5.2 SUmmary</h3>
<ul>
<li>
该两层的碰撞检测系统大纲总结如下, 可见图17.13的描述.

<ul>
<li>
首先, 使用sweep-and-prune算法或者一个grid-based技术, 检测出BV重合的所有物体对, 以及存储在物体对列表中. 

<li>
其次, 发送物体对到精确地碰撞检测算法中, 例如OBBTree.

<li>
最后, 来自碰撞检测的结果转送给应用. 此时采用类似行动(collision response).

</ul>
</ul>

<h2 id="toc_1.6">17.6 Miscellaneous Topics</h2>
<h3 id="toc_1.6.1">17.6.1 Time-Critical Collision Detection</h3>
<ul>
<li>
在章节14.7.3中介绍了一个渲染算法可尝试达到常量的帧率. 这里, 采用的另一种方法则被称为 time-critical collision detection, 当应用使用CD时可使用. 其被称为"time-critical"是因为给定了CD算法一个确定的帧时完成它的任务. 假设一帧20ms, 如果渲染花费15ms, 则CD部分只能使用5ms.

<li>
接下来的算法由Hubbard[572]所介绍, 其思路为以breadth-first order(广度优先)遍历该bounding volume hierarchies. 即意味着在遍历一层的所有节点之前不访问下一层的节点. 其相对应的为 depth-first traversal. 其以最短的路径访问叶子(如章节17.3.2中伪代码所做的). 这里的两个遍历见图17.14. 使用广度优先遍历使得我们可以访问一个节点的左右子树. 即确保了封装整个物体的BV都访问了. 使用深度优先遍历, 我们则可能只访问左子树. 当我们不知道能否有时间遍历整个树时, 最好只遍历一些所有的子树节点. 

<li>
这个算法首先发现所有BV重合的物体对, 例如, 章节17.5.1中的算法, 这些对放置进一个叫Q的队列中, 下一个阶段则开始测试该队列的第一个BV对, 如果其孩子BV测试之后如果重合, 则放置进队列尾部, 而后继续测试队列中下一个BV. 直到该队列为空(所有的树都遍历之后)或者耗完时间[572].

<li>
另一个相关的方法为给每个BV对一个优先级且以该优先级排序队列. 优先级基于visibility, eccentricity(偏心率), 距离等因子. Dingliana和O'Sullivan描述了用于计算近似的collision response 以及近似的 collision contact determination的算法[259]. 这个需要用于time-critical CD, 这是由于时间可能在树遍历完成之前消耗完毕. Mendoza和 O'Sullivan 发表了一个time-critical CD算法用于变形的物体[858].

</ul>

<h3 id="toc_1.6.2">17.6.2 Distance Queries</h3>
<ul>
<li>
tolerance verification(检验, 证实), 其可用于path planning, 也就是一个物体从一个点到另一个点的collision-free path可以被算法确定. 给出物体的速度和加速度, 则使用最短的距离估计在碰撞时间上更低的bound. 以这种方式, 可以避免碰撞检测直到到达该时间[774]. 另一个相关的query为penetration depth, 查找出相互移向对方内部的两个物体之间的距离. 这个距离可用于向后移动该物体使得其刚好不穿透对方. 以及此时计算合适的collision response.

<li>
第一个实用方法有计算convex polyhedra之间最短距离的方法被称为GJK, 其发明者为 Gilbert, Johnson 和 Keerthi[399]. 该算法计算两个convex物体A和B之间的最短距离. 为了完成这个, 则使用A和B之间的difference object(差异物体, 有时候成为sum object)[1291]:

<ul>
<li>
公式17.12

<li>


</ul>
<li>
其也被称为A和(反射的)B的Minkowski sum(见章节16.18.3). 所有的x-y的差值可用于看成一个点集, 其形成一个convex object 类似一个差异的例子可见图17.15.

<li>
GJK的思路为计算A-B的最短距离和原点, 这个与A与B之间的最短距离等价. 这个算法的视觉化可见图17.16. 注意, 如果原点在A-B内, 则A与B重合.

<li>
这个算法从多面体中的一个任意simplex开始, 一个simplex为各自维度中最简单的图元, 所以其为二维中的三角形, 以及三维中的四面体. 而后计算该simplex上最靠近原点的点. Van den Bergen显示了如何通过解线性方程集来完成[1291, 1292]. 则从原点到该最近点形成一个向量. 多面体的所有顶点投影至该向量上, 而后选择有最小投影距离的顶点为新顶点更新该simplex. 由于添加了新顶点, 所以要移除原来simplex中已有的顶点. 则移除有最远投影距离的顶点. 此时, 更新了simplex, 而后算法遍历所有的顶点, 直到该算法不能更新该simplex. 该算法对于两个polyhedra其可在在有限数量的步骤里完成[399]. 可以使用许多的技术提升其性能, 例如imcremental computation 和 caching[1291].

<li>
Van den Bergen描述了一个快速和健壮的GJK的实现[1291, 1292]. GJK还可扩展为计算penetration depth[153, 1293], GJK不是仅有的计算最短距离的算法, 还有Lin-Canny算法[773], V-Clip[870], PQP[730] SWIFT[299], 以及SWIFT++[300](其还计算concave rigid bodies之间的距离).

</ul>

<h3 id="toc_1.6.3">17.6.3 Deformable Models</h3>
<ul>
<li>
除了刚体运动模型或静止模型, 这里还有其他的模型, 例如水的波浪, 随访摇动的布. 不能使用用于刚体的方法, 其可在独立的向量函数中处理每个顶点. 

<li>
假设物体在变形时保持相同的连接性(connectivity), 其可能设计一个聪明的算法利用这个属性. 类似的变形发生于随风舞动的衣服上(除非其被撕开). 作为一个预处理, 可以构建一个初始的层次的围绕体树(initial hierarchical bounding volume). 在变形发生时, 不再重构该树, 而是简单地重新装配(refit)该围绕体用于该变形的几何体[731, 1290]. 通过使用AABBs, 其可以快速地重计算, 操作相当地有效率(相对于OBBs). 另外, 合并k个孩子AABB为一个父AABB也很快, 以及可给出一个最优的父AABB. 然而, 通常, 可使用任意类型的BV. Van den Bergen组织了他的树以便于分配所有的BV并放置进一个数组中. 放置的节点其索引永远比其子节点小[1290, 1292]. 以这种方式, 通过从尾部向后的方式遍历该数组来执行一个bottom-up更新, 重计算每个节点上的每个BV. 这意味着叶子的BV首先被重计算, 而后使用该新计算的BV重计算其父的BV, 直到返回到树的根节点. 这种refit操作的排序被报告为速度十倍快于从scratch中重构树[1290].

<li>
然而, 一般只需要树中少数的BV更新, 这是因为在collision query中, 大多数它们不被使用. 一个混合的bottom-up/top-down更新被发表[731], 其思路为使用bottom-up update用于更高的层(包括根), 即意味着只有更高的BV每帧更新. 这个原理为更高的层常可删除掉大多数的几何体. 这些更新的更高的层和其他的树(也可能为变形的和更新的)进行重合测试. 对于没有重合的节点, 我们可以略过它们子树的更新, 这样可节省很多工作. 对于重合的节点, 使用top-down策略在树的遍历中根据需要更新它们子树中的节点. 当n/2的upper level使用bottom-up方法更新, 更低n/2的层则使用top-down方法, 其可达到好的结果. 这个可见图17.17. 使用top-down更新一个节点, 该节点则记录其整个字数所拥有的顶点, 以及遍历这个列表, 计算一个最小的BV. 当使用top-down更新, 一个BV一更新就执行重合测试, 所以如果没发现重合就可以终止其遍历. 初始的测试显示了这个方法比van den Bergen方法快四到五倍[731].

<li>
有时, 你可用关于变形类型的已知信息创建一个有效率的算法. 例如, 如果使用morphing变形一个模型(见章节4.5), 则你可以和你morph实际几何体相同的方式morph(也为, blend)围绕体层次体系中的BV[732]. 这个没有创建morphing中最优化的BV, 但是其保证了永远包含morphed的物体. 其可用top-down方式执行更新. 也就是, 仅有哪些需要更新的进行更新. 这个技术可用于AABBs, k-DOPs, 以及球体. 计算一个morphed BV, 在k个不同的BV中, 代价为O(k), 通常k很小, 其可看成常量. James和Pai[598]发表了一个有一个reduced deformation模型的框架, 其通过displacement field的组合来描述. 其提供了大量的性能提升. Ladislav和Zara发表了类似的CD技术用于skinned模型[708].

<li>
然而, 当运动为完全无组织的, 可打破物体, 则该方法不能作用. 一些最近的技术尝试跟踪所有BVH中的子树以紧贴其内在的几何体, 以及使用某些启发式, 在需要时重建它们[733, 1397].

<li>
另一个用于变形物体的方法是首先计算要碰撞的两个物体周边最小的AABBs. 如果重合, 则计算重合的AABB区域. 其仅为AABB的相交volume. 只有在重合区域里面时, 才会有碰撞发生. 创建在该区域内所有三角形的列表. 则使用可用于环绕整个场景的octree. 其思路为插入三角形到octree的节点, 如果来自两个物体的三角形被发现在一个叶子节点中, 则这些三角形重新相互测试. 可用某些优化. 首先, 不需要显式地构建该octree, 当一个节点得到一个三角形列表, 则再次测试该三角形与其八个孩子节点, 以及创建新的八个三角形列表. 递归直到叶子上. 即triangle/triangle测试可以发生的地方.  其次, 这个递归可以在任意时候三角形列表只有来自一个物体的三角形时结束. 为了避免测试一个三角形对多次, 一个checklist保持和跟踪测试对. 这个方法的效率在当一个重合区域非常大时或者许多三角形在重合区域时则崩溃.

</ul>

<h3 id="toc_1.6.4">17.6.4 Collision Response</h3>
<ul>
<li>
这是一个很多人研究的课题[58, 258, 478, 869, 901, 1363]. 这是一个复杂的课题, 本章节只介绍最简单的技术.

<li>
在章节16.18.3, 介绍了用于计算球体和一个平面的碰撞精确时间的技术. 这里解释在碰撞时球的运动发生了什么.

<li>
假设一个球体移动向一个平面. 速度向量为v, 平面为π: n・x + d = 0. 见图17.18. 计算最简单的反应, 我们发表速度向量如下:

<ul>
<li>
公式 17.13

<li>


<li>


</ul>
<li>
则在碰撞之后, 速度v'如下[718]: 

<ul>
<li>
公式 17.14

</ul>
<li>
如果碰撞之后又能量损失, 则使用restitution系数k(常被记为ε). 则计算碰撞之后的速度v'如下, 其中k属于0到1的范围内.

<ul>
<li>
公式 17.15

</ul>
<li>
k越小, 能量损失越大.

<li>
创建一个使用一个ordinary differntial equation(ODE) solver来解的公式系统. 在这样的算法中, 需要碰撞点以及在该点的法线. 有兴趣的可以看Witkin[1363]的SIGGRAPH课程或者Dingliana[258]的论文. O'Sullivan和Dingliana还发表了实验表示人们很难判断一个collision response是否正确[977, 978]. 尤其是当包含更多维度时. 在实时算法中, 当发现没有足够时间计算精确的反应, 则可使用随机地碰撞反应. 其发现这个可令人相信为更精确的反应.

</ul>

<h3 id="toc_1.6.5">17.6.5 GPU-Based Collision Detection</h3>
<ul>
<li>
早就知道可以使用光栅化检测碰撞[1168]. 与之前算法的主要区别为其基于GPU, 且常在图像空间中执行. 与其相反的技术则为直接在几何体上操作.

<li>
这里有大量的算法执行GPU上的CD, 以及我们将发表其中一个算法, 称之为 CULLIDE[436]. 其基本思路为使用occlusion queries(见章节14.6.1)执行一个测试来确定一个物体O是否"完全可见", (也就是, 没有碰撞到)其他的物体集S. occlusion query常用 less-or-equal 深度测试. 该occllusion query会计数通过深度测试的片段数量, 如果没有片段通过, 则我们可确定被渲染的物体(或者他的围绕体)被深度缓存的内容给occluded(遮蔽).

<li>
对于碰撞检测, 我们有兴趣的不是查找没有被其他物体重合的物体. Govindaraju则建议反转这个深度测试, 所以我们使用greater-or-equal, 以及关闭写入深度缓存. 如果物体的所有前面和背面都被渲染后, 没有片段通过深度测试, 则该物体对于深度缓存完全可见. 以这种方式, 我们在深度方向中和图像平面中测试重合.

<li>
接下来, 我们描述如何在GPU上使用该测试实现broad-phase collision. 假设有n个物体, 记为O[i], 1 &lt;= i &lt;= n. O[i]不和其他的物体碰撞则意味着不和O[1], ..., O[i-1], O[i+1], ..., O[n]碰撞. 其可公式化为有效率的渲染算法. 在第一个通道中, 物体一次渲染. 以及我们测试是否每个物体相对于已渲染物体完全可见. 所以, 当O[i]正在渲染, 则与O[i], ..., O[i-1]测试. 在第二个pass中, 我们以相反的顺序渲染物体. 则意味着O[i]与O[i+1],...,O[n]相测试. 使用正交投影完成这个渲染, 且通常每个轴(x, y, 和z)完成一次. 换句话, 在六个view中求解该物体. 来自所有六个view的任意重合对其可能意味它们碰撞. 其结果为物体可能碰撞的一个小的物体集, 这个集称之为 potentially colliding set(PCS). 可通过使用其他的物体level来改进该测试. 也就是, 通过分割每个物体为一个更小的子物体集, 以及继续类似的测试. PCS中剩下的物体或三角形则通过CPU测试真正的重合.

<li>
应当注意到这些图像空间类型的算法性能和精确度与屏幕分辨率, the case of CULLIDE, 也与深度缓存的精确度有关. 通常, 更高的分辨率有更好的精确度和PCS中更少的物体, 但影响填充率要求. 为了正确地结果, 我们需要保守的rasterizer[509]. 原因为rasterizer通常仅在几何体像素的中心上采样. 对于碰撞检测其所需要的为一个rasterizer访问与正渲染的几何体重合的每个像素. 标准光栅化何时出现错误的例子可见图17.19. 注意, 该问题可通过更高的分辨率改善, 但是不能完全避免该问题.

<li>
Govindaraju[438]扩展CULLIDE系统使得可以使用心得visibility测试算法处理self-collision detection(对于可变形的物体). Georgii[389]则使用depth peeling检测在深度方向中可能的碰撞, 以及一个围绕盒mipmap层次体系进一步prune该PCS. 最后, 一个sparse纹理打包进更小的表示(representation), 以及读回至CPU用于精确地polygon-polygon测试. 物体间的碰撞可简单地通过绘制碰撞区域至纹理上正确地变形该物体[1381]. 

</ul>

<h2 id="toc_1.7">17.7 Other Work</h2>
<ul>
<li>
Eberly 扩展了OBBTree算法用于处理dynamic collision detection[294], 这个工作简短地在IEEE CGA[89]中描述. Wilson[1355]则介绍了用于极端大模型(百万个三角形)碰撞检测的算法. 他们使用了一个被称为the overlap graph, lazy creation of BVHs, temporal coherence, and more的数据结构来组合球体, AABBs, OBBs的BVHs, 到一个称为IMMPACT的系统. 存储一个bounding volume hierarchy可能使用很多的内存, 所以 Gomez发表了一些方法用于压缩AABB树[421].

<li>
Prisken[365]介绍了一个框架用于soft bodies, 其当碰撞时, 冲击力, 和contact determination可以被有效率地计算. 他们的框架基于adaptively sampled distance fields(ADFs), 一个相对新的shape representation[364].

<li>
Baraff和Witkin[59]及Hughes[575]介绍了一个碰撞检测算法用于经历多项式变形(polynomial deformation)的物体. 另一个用于任意变形物体的通用系统由Ganovelli[375]发表. 有关到他用于衣服的response和碰撞检测的算法. 这个由Baraff和Witkin[61]处理, 还有Volino和Magnenat-Thalmann[1307, 1308]. 另一个复杂的现象为头发的CD. Hadap 和 Magnenat-Thalmann[473]处理头发为一个连续集(continuum, 其可能使得相对快速地模拟头发.

<li>
Quinlan[1042]提出Distance queries可以扩展处理concave(凹的) objects. Ehmann和Lin也通过分解物体为convex部分来处理concave objects[300]. Kawachi和Suzuki发表了另一个算法用于计算concave部分之间的最短距离[638].

</ul>

</body>
</html>
