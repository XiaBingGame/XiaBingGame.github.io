<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<link rel="Stylesheet" type="text/css" href="../../../../../style.css">
<title>RealTimeRendering16</title>
<meta http-equiv="Content-Type" content="text/html; charset=cp936">
</head>
<body>

<h1 id="toc_1">Chapter 16 Intersection Test Mothods</h1>
<ul>
<li>
相交测试常用语计算机图形. 我们可能希望用鼠标点击一个物体, 确定两个物体是否碰撞, 或确保我们的viewer在地面之上常量的高度以便navigate一个建筑物. 所有这些操作都可执行相交测试. 在本章中, 我们将讲述大多数常用的 ray/object 和 object/object 相交测试.

<li>
在互动的计算机图形应用程序中, 常需要用户通过鼠标或者其他输入设备的点击(picking-clicking)来选择一个确定的物体. 当然, 类似该操作的性能要求很高. 由OpenGL所支持, 在很小的pick窗口中渲染所有的物体. 重合在该窗口的所有物体返回一个列表. 沿着最小和最大的深度值以发现每个物体. 这个系统的排序通常有额外的优势, 其能够在线条和顶点上picking, 而不只surface上. pick方法通常完全识现在host处理器上, 且不使用图形加速器. 一些其他的picking方法使用图形硬件, 具体可见章节16.1.

<li>
相交测试提供一些OpenGL其picking方法所不能提供的好处, 其中一个比较一个ray和一个三角形, 另外一个要通过OpenGL发送三角形且还需要被pick窗口裁剪, 而后询查哪个三角形被pick. 前者速度更快. 相交测试方法可以计算位置, 法线向量, 纹理坐标, 以及其他的surface数据. 类似的方法还独立于API的支持

<li>
可以通过使用分层的 bounding volume来有效率地解决该picking问题(见章节14.1.1). 首先, 我们计算来自相机位置的ray通过用户picked的像素. 而后, 我们递归地测试该ray是否击中该层的围绕体.如果任意时刻该ray没有击中围绕体(BV), 则可以丢弃该子树避免进一步的测试. 然而, 如果一个ray击中一个BV, 则还需要测试其孩子BV. 最后, 该递归可能结束于一个包含几何体的叶子中. 而后该ray必须和该几何节点中的每个图元进行测试.

<li>
正如章节14.3我们所见, view frustum culling为一个手段, 用于有效率地抛弃在view frustum之外的几何体. 测试其决定一个bounding volume是否完全在外面, 完全在里面, 或者部分在里面都需要这个方法.

<li>
在碰撞检测算法中(见第17章), 其也要分层建设, 该系统必须确定两个图元是否相撞. 这些图元对象包含三角形, 球体, 轴对齐围绕盒(AABBs), oriented bounding boxes(OBBs), 以及discrete oriented polytopes(多面体)(k-DOPs).

<li>
在所有的这些情况中, 我们面对要求相交测试的确定的一个问题类. 一个相交测试确定两个物体, A和B, 是否相交.  其中A可能完全在B内(或者相反), 则A和B的边界相交, 或者它们完全不相交. 然而, 有时, 可能需要更多的信息, 例如最近的相交点, 到达该相交点的距离, 等等.

<li>
在本章中, 识别和研究一系列快速地相交测试方法. 我们不仅发布基本的算法, 还给出建议如何构造新的和有效的相交测试方法. 自然地, 本章发表的算法还可用于离线计算机图形应用中. 例如, 章节16.6发表的算法可以用于ray tracing和global illumination程序.

<li>
在简略地讲述hardware-accelerated pick方法之后, 本章继续一些有用的定义, 接着讲述形成围绕图元的围绕体的算法. 而后发表用于构造有效率的相交测试方法的经验规则. 最后有相交测试方法的cookbook.

</ul>

<h2 id="toc_1.1">16.1 Hardware-Accelerated Picking</h2>
<ul>
<li>
这里有一些hardware-accelerated picking方法值得提起, 其中一个方法首次由Hanrahan 和 Haeberli[497]发表. 为了支持picking, 渲染场景时, 其每个多边形都有一个唯一的颜色值作为identifier. 存储这个形成的图像, 而后用于极端快速的picking. 当用户点击到一个像素, 则在该图像中查找该颜色identifier, 而后立刻识出该多边形. 这个方法的主要缺点为, 必须在单独的pass中渲染整个场景以支持sort of picking. 这个方法原先发表在一个三维绘制(paint)系统的上下文中. 在其应用程序的这个排序中, 每个view其picking的数量很高, 所以用于该view其一次形成这个buffer的代价则变得微不足道的.

<li>
还可使用color buffer还可以发现三角形内部一个点的相对位置[724]. 使用 Gouraud shading 渲染每个三角形, 其三角形顶点的颜色为红色(255, 0, 0), 绿色(0, 255, 0), 蓝色(0, 0, 255). 如果说拾取的像素颜色为(23, 192, 40), 则意味着红色顶点的作用为因子 23/255, 绿色为192/255, 蓝色为40/255, 这个信息可用于发现在三角形上该点的实际坐标, 以及该picked点的纹理坐标(u, v), 还有法线的插值. 这个值为重心坐标, 可见章节16.8.1的进一步讨论. 在相同的方式中, 顶点的法线可以被直接地编码为RGB颜色. 每个法线的成员其[-1, 1]范围转换为[0, 1], 这样可以用于渲染. 有选择地, 可以直接渲染至一个浮点buffer, 而不需要变换. 在使用Gouraud shading渲染三角形之后, 任意点上法线可以从颜色buffer中读取.

<li>
使用GPU加速selection的可能性被新的硬件和API直接显著地增加了. 类似几何着色器, stream out, 以及 triangle identifier的功能可以被着色程序利用, 以打开新的方式生成selection sets, 以及知道什么在一个pick窗口中. 

</ul>

<h2 id="toc_1.2">16.2 Definition and Tools</h2>
<ul>
<li>
本节介绍了用于整个章节的记号和定义.

<li>
一个光线, r(t), 由原点o定义, 方向向量d(为了方便, 其通常被单元化, 所以||d||=1). 其数学公式见公式16.1, 还可见图16.1中ray的图解.

<li>
公式16.1

<li>


<li>
标量t为一个用于生成ray上不同点的变量. 小于0的t值则位于ray原点之后(不是ray的一部分), 正的t值则位于之前. 同样, 由于ray方向已经单元化, 一个t值生成ray上的一个点, 其位于到原点t个单元的位置.

<li>
实际上, 我们常存储当前的距离l, 及我们需要沿着ray查找的最大距离. 例如, 当picking时, 我们常想要沿着ray最近的相交. 在相交之外的物体可以安全的忽略掉. 距离l开始于∞, 当物体成功地相交, l更新为这个相交的距离. 在 ray/object 相交测试中, 我们则不包含l. 如果你想使用l, 你必须执行正常的ray/object测试, 而后检查l和计算出来的相交距离, 而后采取合适的动作.

<li>
当我们讲到surface, 则应区分隐式(inplicit)surface和显式(explicit)surface. 所有的隐式surface都可以由公式16.2定义:

<li>
公式16.2

<li>


<li>
这里P为surface上的任意点, 即意味着, 如果你有surface上的一个点, 将该点插入f中, 其结果则为0.  否则f的结果则为非零值. 例如一个球面的表达式, P点三个坐标的平方和等于r的平方. 可重写f(p)为三个坐标的平方和减去r的平方等于0. 隐式surface可见章节13.3的简略描述. 可见Bloomenthal等[117]其关于大范围种类的隐式surface的建模和渲染.

<li>
对于显式surface, 另一方面, 其由一个向量函数f和一些参数(ρ,φ)定义 ,这个参数生成在surface上的点P, 如下公式16.3显示了这个通用的观点:

<li>
公式16.3

<li>


<li>


<li>
一个再次关于球面的显式surface, 这次表示成一个球面坐标, ρ为为维度, φ为经度, 可见公式16.4

<li>
公式16.4

<li>


<li>


<li>
在另一个例子中, 一个三角形 △V1V2V3, 可描述成显式形式: t(u, v) = (1-u-v)V0 + uV1 + vV2, 其中 u&gt;=0, v&gt;=0, 以及 u+v &lt;=1.

<li>
最后, 我们应当给出三个围绕体的定义, 分别名为AABB, OBB, k-DOP, 这些被广泛地使用.

<li>
定义: 一个 axis-aligned bounding box(也称之为 rectangular box), 简称为AABB, 其为一个箱子, 它的面法线和标准基坐标系一直. 例如, AABB, A描述了两个对角线的顶点Amin和Amax, 其中 Amin中任意的坐标成分都小于Amax中对应的坐标成分.

<li>
图16.2描述了一个AABB以及它的记号.

<li>
定义: 一个oriented bounding box, 缩写为OBB, 其为一个箱子, 且任意两个面的法线相互正交. 即其为AABB任意旋转后的结果. 一个OBB, B由该box的中点Bc, 以及三个法线Bu, Bv, Bw所描述. 其描述了box的面方向(side direction). 在中心点上, 各个方向在箱子的一半长度分别表示为 HuB, HvB, HwB, 其为中心Bc到各自面中心的长度.

<li>
图16.3描述了一个三维ODD以及它的记号.

<li>
一个k-DOP(discrete oriented polytope)它的定义由以下组成, 有k/2(k为偶数)个单元化的法线(方位), Ni, 1 &lt;= i &lt; k/2, 以及每个Ni有两个相关联的标量值 DiMIN 和 DiMAX, 其中 DiMIN &lt; DiMAX. 每个三元组(Ni, DiMIN, DiMAX)描述了一个slab(平板), Si, 其为两个平面间的volume, πiMIN: Ni*x + DiMIN = 0 和 πiMAX: Ni*x + DiMAX = 0, 以及所有slabs的交集, ∩1&lt;=l&lt;=k/2 Sl,  为实际的k-DOP volume. 该 k-DOP被定义为一个围绕物体最贴近物体的(tightes)slabs集合.

<li>
图16.4 描述了一个二维中的8-DOP.

<li>
一个单独的轴, 其指定了一条线, 如果两个物体没有重合(不相交的), 两个物体投影在该线上, 其结果也不会重合. 类似地, 一个平面可以插入两个三维物体之间, 该平面的发现定义了一个单独的轴. 接下来一个重要的用于相交测试的工具[433, 451], 其工作于convex polyhedra(多面体), 例如 AABBs, OBBs, 以及 k-DOPs. 其也是单独的超平面(hyperplane)定理(theorem)的一方面.

<li>
Separating Axis Test(SAT), 对于任意两个随意的, 凸出的, 不连接的多面体, A和B, 至少有一个轴, 这两个多面体在轴上有间隔. 如果其中一个物体为凹面的, 则不能有这个结果. 例如, 一口井的墙壁不和其内的桶相交, 但是没有一个平面可以划分它们. 进一步的, 如果A和B不连接的, 则他们可以被一个轴分开, 轴之间相互为正交的.

<ol>
<li>
A 面

<li>
B 面

<li>
来自每个多面体的一条边(例如, 叉乘)

</ol>
</ul>

<ul>
<li>
这个测试可见页768图16.21中两个箱子的图解. 一个线段和一个凸多边形也为一个凸多面体, 由于线段A不含一个面, 所以第一个测试消失. 这个测试的使用来源于章节16.7.2的箱/线段重合(box/line segment overlap)测试. 章节16.12的triangle/box overlap test, 以及16.13.5的OBB/OBB overlap test.

<li>
返回这些方法的讨论, 其可施加一个用于优化相交测试的技术, 其可使得早先一些简单的计算可以确定ray或者object是否完全的miss其他的object. 类似地一个测试称之为 rejection test. 如果该测试成功了, 则该相交可以说被rejected.

<li>
另一个本章中常用的方法为投影这个三维物体到"最好的"正交平面(xy, xz, 或者 yz), 以及在二维中解决问题.

<li>
最终, 由于数字的精确度, 我们常在相交测试中使用非常小的数. 该数记为ε(epsilon---希腊语字母之第五字, 小的正数), 以及它的值会在测试到另一个测试中变化.  然而, 选择一个epsilon作用于程序员的问题情况(Press[1034]称之为a "convenient fiction"), 与之对照的是, 小心四舍五入的错误分析以及epsilon修正. 类似的代码用于另外的设置可能会违反, 这是由于其不同的情况. Ericson的书[315]在几何体计算的上下文中深入讨论了数字健壮的领域. 我们有时试图提供一个epsilon其至少为合理的起始值用于"normal"数据(法线), 很小大小的(小于100, 大于0.1)和接近于原点的值. 

</ul>

<h2 id="toc_1.3">16.3 Bounding Volume Creation</h2>
<ul>
<li>
给定一个物体的收集, 查找一个紧贴适合的围绕体是最小化相交代价的重要关键. 任意ray击中任意凸出物体的几率与物体surface的面积成正比(见章节16.4). 最小化这个面积可以增加任意相交算法的效率, 正如一个rejection从不比一个相交计算更慢. 作为对比, 最小化每个BV的volume用于碰撞检测算法.这个章节简略的讲述查找给定多边形集合其最优化或者近似最优化的围绕体的方法.

</ul>

<h3 id="toc_1.3.1">AABB and k-DOP Creation</h3>
<ul>
<li>
创建最简单的围绕体为AABB, 去多边形沿着每个轴坐标最小和最大的范围值, 则可以形成一个AABB. k-DOP为AABB的扩展, 投影顶点至k-DOP的每个法线上Ni, 而后取这些投影的极端值(min, max), 并存储到DiMIN和DiMAX中, 这两个值定义了该方向最紧贴的slab. 同时, 所有类似的顶点定义了一个最小的k-DOP. 

</ul>

<h3 id="toc_1.3.2">Sphere Creationg</h3>
<ul>
<li>
一个快速的, 常量时间的单pass算法为形成该多边形集的AABB, 而后使用它的中心以及对角线形成一个球体. 但这个有时给出很少的fit, 可以通过另一个快速的pass来改进该fit: 开始于AABB的中心作为球BV的中心, 通过所有的顶点, 以发现到该中心最远的顶点(使用距离的平方值比较, 以避免使用平方根), 而后这个为新的半径. 

<li>
Ritter[1070]发表了一个简单的算法其创建一个近似优化(near-optimal)的bounding sphere. 其思路为沿着x, y, z轴发现其上最大和最小的顶点. 对于这三对顶点, 查找它们之间距离最大的一对顶点. 使用这一对顶点形成一个球体, 球心为它们的中点, 半径等于中点到这对顶点的距离. 通过所有的顶点, 检查这些顶点到球心的距离d, 如果该顶点在球的半径r之外, 球心向该顶点移动 (d-r)/2, 设置球半径 (d+r)/2, 而后继续. 这个步骤可以封闭该顶点, 以及原来的球体会在新的球体内. 在第二次通过该列表之后, 该围绕球包含了所有的顶点, 网上有代码可用.

<li>
Welzl[1339]发表了更复杂的算法, 其由Eberly[294, 1131]和Ericson[315]实现, 网上代码可用. 对于顶点的随机列表, 该算法期待为线性的(平均地看来随机化可以帮助快速地发现一个好的球体). 其思路为发现一个点的支持集来定义一个球体. 可以通过它的surface上两个, 三个, 或四个的点集来定义一个球体. 当一个顶点发现位于当前球之外, 则它的位置加入支持集. (以及可能旧的支持顶点从该集中移除), 而后计算新的球体, 然后再次运行通过整个列表. 重复这个处理直至球体包含所有的顶点. 当该方法比之前算法更复杂, 但保证了一个最优化的围绕球被发现.

</ul>

<h3 id="toc_1.3.3">OBB Creation</h3>
<ul>
<li>
OBB的形成, 有其任意的基坐标系方位, 其比查找一个合理的围绕球更加复杂. 由Gottschalk[434]发表的一个方法, 接着由Eberly[294]简略解释另一个方法.

<li>
其显示出可以从convex hull的三角形中计算出一个方位来发现一个封装物体的tight-fitting OBB[433, 434]. 使用convex hull是因为其避免使用不影响box方位的物体内部中的点. 同样, 在convex hull的每个三角形上执行一个积分. 完成这个是因为使用convex hull的顶点会促成一个 bad-fitting box. 如果, 举例, 若干顶点群集在一个小的区域内. 这里, 我们将发表一个公式使用一个统计的方法计算一个 good-fit OBB. 这个推导可见Gottschalk的博士论文[434].

<li>
首先, 必须计算出一个物体的convex hull. 这个可以使用 Quickhull 算法[62]. n个三角形定义为△PkQkRk(上标), 其中 Pk, Qk, Rk为第k个三角形的顶点, 0 &lt;= k &lt;= n. 我们还标记第k个三角形的面积为 Ak, 则该convex hulll总的面积为 Ah 为 k=0到k=n-1的Ak之和. 更进一步, 三角形i的中心为 Mi = (Pi + Qi + Ri)/3, 即为这些顶点的平均. 整个convex hull的中心为 Mh, 其为三角形中心的权重平均, 公式16.5如下:

<li>
公式16.5

<li>


<li>
使用这些定义, 我们发表一个公式计算一个 3x3的 coveriance matrix, C, 它的特征向量(见章节A.3.1, 如何计算一个特征向量)为用于一个good-fit box的方向向量.

<li>
公式16.6

<li>


<li>


<li>
在计算C之后, 计算特征向量并单元化, 这些向量为OBB方向向量, Au, Av, Aw. 接着我们需要发现OBB的中心和半长. 这通过投影convex hull的点到方向向量上, 以及查找每个方向的最大和最小值. 而后确定了该box的大小和位置. 也就是, 按照OBB的定义指定该OBB(见章节16.2).

<li>
当计算OBB时, 最吃力的操作为该convex hull的计算, 其花费了 O(nlogn) 时间, n为该物体图元的数量. 这个basis(基坐标)的计算花费了至多不超过线性的时间. 以及特征向量的计算花费了常量时间, 即意味着计算一个用于n个三角形集的OBB花费了 O(n logn)的时间.

<li>
Eberly[294]发表了一个方法使用一个最小化的技术计算一个 minimum-volume OBB. 其优点为不需要计算该convex hull. 这个为迭代的算法, 所以该box的初始猜测决定该解决方案聚集到最小化的box有多快. 对于一个box, 使用轴Au, Av, Aw, 点投影到这些轴上, 沿着Au发现最小的KuMIN和最大的KuMAX. 而后类似地计算出KvMIN, KvMAX, KwMIN, KwMAX, 则该box的中心为,

<li>
公式16.7

<li>


<li>


<li>
而后计算box其边的半长 Hl = (KlMAX - KlMIN)/2, l为{u, v, w}. Eberly 采用box的可能的方向集, 以及使用那个box其对于numeric minimizer起点为最小的那个轴. 而后 Powell的方向集方法[1034]用于发现该minimum volume box. Eberly在网上有这个操作的代码[294].

</ul>

<h2 id="toc_1.4">16.4 Geometric Probability</h2>
<ul>
<li>
通用的几何操作包含一个平面或ray是否相交于一个物体, 以及一个点是否在物体内. 一个相关的问题为一个点, ray, 或平面与一个物体相交的相对概率. 一个随机点在物体内空间的概率相当地明显, 其和物体的体积成正比. 所以对于可能包含一个随机地选中点, 1x2x3 的box其概率六倍于1x1x1的box.

<li>
对于空间中任意的一个ray, 其相交于一个物体和相交于另一个物体的相对几率为多少? 这个问题与另一个问题相关: 当使用正交投影时, 一个物体覆盖的平均像素数为多少? 正交投影可以看成view volume中的一个平行rays的集合, 其ray遍历通过每个像素. 给出一个随机地定向(oriented)物体, 其覆盖的像素数量等于和该物体相交的ray的数量.

<li>
由Nienhuys[935]提出的用于凸出物体的非正式解决方案如下:

<ol>
<li>
想象一个等边三角形其有随机的方位, 且大量次数地投影至一个平面. 三角形的平均投影面积除以实际的surface面积的比率为某常量(虽然未知的)值 f.

<li>
所有的三角形, 在其极限之下(at the limit), 可以被tessellated为不同大小的等边三角形. 所以所有形状的三角形其f为相同的ratio. 

<li>
所有的convex object在其极限情况下可以被tessellated三角形.

<li>
所有的(非退化的)convex objects从任何角度都有一个2的深度复杂度.

<li>
一个球为一个convex object, 以及它的表面积为 4π乘以r的平方.

<li>
一个球的正交投影总是为一个圆, 且其面积为π乘以r的平方.

</ol>
<li>
所以一个球的投影面积总是为1/4的表面积, 即为, 对于一个球体, 也对于任意的convex object, 其 f = 1/4.

<li>
一个球体有2的深度复杂度, 所以永远有球上的两个点投影至投影圆上的一点. 这让我们知道, 对于一个三角形的f为何: 2的深度复杂度为1/4倍. 也就是, f = 1/2, 即意味着任意多边形投影一个平均的表面积等于1/2它的实际表面积. 

<li>
所以对我们原先的问题, 一个 1x1x1 的box其表面积为6, 一个1x2x3的box其表面积为22, 因此, 第二个箱子有第一个箱子 22/6 = 3.67(约等于)的可能性被任意的ray击中.

<li>
这个度量(metric)涉及到当该surface area heuristic(SAH)[35, ]在ray tracing的文献中. 其对于有效率的形成用于数据集的可视结构很重要.  一个用于在比较的围绕体效能中. 例如, 一个球体其被ray集中的相对概率为1.57(π/2). 相对于一个inscribed cube(也就是, 一个立方体他的角接触到球体). 类似地, 一个cube有一个被击中的概率为1.91(6/π), 相对于一个球体在其内. 

<li>
这种类型的概率测量可能对类似level of detail计算的领域很有用. 例如, 想象一个很长且薄的物体覆盖了许多比一个更圆的物体(rounder object)更少的像素, 且已经有相同的bounding sphere大小. 从bounding box的面积预先知道这个, 当其改变了它的level of details时, 长且薄的物体可能分配一个不同的屏幕面积.

<li>
同样, 对于知道一个平面相交一个convex object, 以及该平面相交另一个 convex object的相对可能性也很有用. 类似于表面积, 平面相交一个box的几率与该box在三维中的范围(extents)之和成正比[1136]. 这个总和称之为物体的mean width. 举例, 边长为1的立方体其mean width为 1+1+1 = 3. 一个box的mean width正比于其被一个平面击中的几率. 所以一个 1x1x1 box有一个3的尺寸(measure), 以及一个1x2x3的box有一个6的尺寸. 意味着第二个box有两倍的可能性被任意的一个平面相交.

<li>
然而, 该总和大于真正的几何mean width, 即沿着一个固定轴在所有可能的方位集上的平均投影的长度. 对于mean width的计算, 在不同的convex object types之间没有宽松的(easy)关系. 直径d的球体有一个为d的几何的mean width. 这是因为从任意方位上, 该球的spans都为相同的长度. 我们简单的说明这个主题, box的dimension之和乘以0.5得到它的几何mean width, 其可直接和球的直径比较. 所以 1x1x1的box为3乘以0.5 = 1.5的geometric mean width. 围绕该box的球则有直径根号3 = 1.735. 因此围绕该cube的球比该cube有1.732/1.5=1.115倍于相交于任意平面的可能性. 应该注意到, 最紧贴一个物体的球在某些情况下比某些其surface封装了所有物体围绕盒角的球更小.

<li>
这些关系对于确定不同算法的好处时很有用, frustum culling为一个首要的候选, 当其包含于围绕体相交的平面时. 使用一个球还是一个box用于围绕体的相对好处可以计算出来. 另一个使用则为用于确定是否以及哪里分割一个BSP 节点包含的物体, 所以furstum culling的性能变得更好(见章节14.1.2).

</ul>

<h2 id="toc_1.5">16.5 Rules of Thumb</h2>
<ul>
<li>
在开始学习具体的相交法之前, 这里有一些经验可以让你能更快的,更健壮的, 更精确的相交测试. 在设计, 虚构, 和实现一个相交程序时记在心里.

<ul>
<li>
初期在可能琐碎的reject或accept不同类型的相交上执行计算以便能够初期避开进一步的计算.

<li>
如果可能, 利用之前测试的结果.

<li>
如果使用多于一个的rejection或acceptance test, 而后试图改变他们的内部次序(如果可能), 这是由于可能导致更有效率的测试. 不要假设一个monitor要改变的出现内容是什么, 这样会没有效率.

<li>
延迟昂贵的计算(特别是三角函数, 平方根, 以及除法), 知道它们确实需要(见章节16.8延迟昂贵除法的例子).

<li>
常常可以通过降低问题的维度来大大简化相交的问题.(例如, 三维到二维, 甚至到一维). 见章节16.9的例子.

<li>
如果单个ray或者物体一次和许多其他物体比较, 可以查找在测试开之前仅仅一次完成的预计算.

<li>
无论何时一个相交测试都是昂贵的, 故常最好开始于一个球或者其他简单的BV来围绕该物体可以给出first level的快速rejection.

<li>
养成一个习惯, 要永远在你的计算机上执行时间比较, 以及使用实际的数据和测试环境用于计算时间.

<li>
最后, 尝试让你的代码健壮, 这意味着它应当作用于所有的专用情况, 以及因为尽可能多的浮点精度错误导致的不灵敏问题. 小心任意的其可能有的限制. 对于关于数字和几何健壮的更多信息, 可以查看Ericson的书[315].

</ul>
<li>
最终, 我们重点在于很难确定一个用于特定测试的"最好的"算法这个事实. 对于赋值(evaluation), 一个不同集的随机数据, 常使用predetermined hit rates(预确定的击中率), 但是其显示只有部分为真. 然而, 这个算法仍是用于实际的场景(scenarios). 例如, 在一个游戏中, 在上下文中其最好的赋值. 以及更多测试的场景. 更好地理解你得到的性能问题. 进一步, 算法趋向于在不同CPU架构上不同的行为, 以及也需要检查该算法是否能够跨平台工作地很好.

</ul>

<h2 id="toc_1.6">16.6 Ray/Sphere Intersection</h2>
<ul>
<li>
我们开始数学上简单的测试----也就是, 一个ray和一个球体之间.

</ul>

<h3 id="toc_1.6.1">16.6.1 Mathematical Solution</h3>
<ul>
<li>
一个球体可以有一个中心点 <strong>c</strong> 和一个半径 <strong>r</strong> 来定义. 用于球体更紧凑(compact)的隐式公式如下:

<li>
公式16.8    f(<strong>p</strong>) = ||<strong>p</strong> - <strong>c</strong>|| - <strong>r</strong> = 0.

<li>
其中 p 为球面上的任意点. 为了解决一个ray和一个球体之间的相交, ray <strong>r</strong>(t)简单地替换公式16.8中的p以生成:

<li>
公式16.9    f(<strong>r</strong>(t)) = ||<strong>r</strong>(t) - <strong>c</strong>|| - <strong>r</strong> = 0.

<li>
使用公式16.1, 其中 <strong>r</strong>(t) = <strong>o</strong> +t <strong>d</strong>, 公式16.9可简化如下:

<ul>
<li>
公式 16.10 

<li>


<li>


<li>


<li>


</ul>
<li>
最后一步中d假设已被单元化. d*d = ||d||^2 = 1. 不奇怪, 最后的公式为二次多项式, ray最多两个点和球相交.

<li>
公式16.10可以写成一个二次方程:

<ul>
<li>
公式16.11

</ul>
<li>
其中 b = d*(o-c), c = (o-c)*(o-c) - r^2. 该二次方程的解如下:

<ul>
<li>
公式16.12

</ul>
<li>
注意, 如果 b^2 - c &lt; 0, 则该ray没有击中球体, 且rejection该相交, 以及避免计算(例如, 平方根以及其他). 如果通过测试, 则可以计算出两个解t0和t1. 为了查找t0和t1中最小的正值, 还需要进行额外的计算.

<li>
如果这些计算被替换为从view的一个几何点观察(view), 可以发现一个更好的rejection测试.

<li>
对于其他二次的, 也就是, 圆柱体, 椭圆体, 圆锥体, 以及双曲线体(hyperboloid), 它们相交问题的解决方案和球体一样的简单直接. 有时, 然而, 其有必要围绕一个surface, (例如, 通常你不想要一个无限的圆柱体, 所以必须在两端上加上圆柱帽), 该surface可添加一些复杂性至代码.

</ul>

<h3 id="toc_1.6.2">16.6.2 Optimized Solution</h3>
<ul>
<li>
对于 ray/sphere 的相交问题, 在ray原点之后的相交是不需要的(这在picking的情况中是正常的, 等等.). 因此, 计算一个向量 l = c - o, 为ray原点到球心的向量. 图16.6中描述了使用的所有记号. 同样, 计算该向量的平方长度, 即为两个向量l的点乘. 现在如果 l的平方 &lt; r的平方, 其则暗示了ray的原点在球内, 反过来, 意味着保证该ray击中该球体, 如果我们仅仅检测该ray是否击中球体, 则此时我们可以退出, 否则, 进一步处理. 接下来, 计算l到ray方向d上的投影: s = l*d. 现在, 开始第一个rejection测试, 如果 s &lt; 0, 且 ray原点在球外, 则, 该球体在ray原点之后, 以及我们可以rejection该相交. 否则, 使用Pythagorean原理(公式 B.6)计算球心到该投影的距离的平方: m的平方 = l的平方-s的平方. 第二个rejection测试则更简单: 如果 m的平方 &gt; r的平方, 则该ray不和球体相交, 以及余下的计算可以省略掉. 如果该球体和ray通过最后的测试, 则保证该ray击中该球体, 以及此时可以退出. 

<li>
为了发现实际的相交点, 还需要做一点更多的工作. 首先计算求解平方距离 q的平方 = r的平方 - m的平方(见图16.6), 由于r的平方 &gt; m的平方, 则可以求解出实数解 q. 最后求解的 t = (s 加或者减 q). 其解非常类似在之前数学解决方案章节中得到的二次方程. 如果我们只对第一个, 正的相交点感兴趣, 则当ray原点在球体外则使用t1=s-q用于该解, 如果ray原点在球体内, 则使用 t2 = s+q. 通过插入t值(s)到ray方程来发现真正的相交点(公式16.1).

<li>
伪代码显示如下, P741, 这个程序返回一个布尔值告知为REJECT还是INTERSECT. 如果相交, 则返回t以及相交的点p. 

<li>
该算法前面部分可以执行一些rejection测试, 以避免后面继续处理, 这样可以节省时间.

<li>
对于其他的二次和混合的(hybrid)物体月一个ray的相交计算, 也存在一个最优化的几何算法, 例如, 有方法用于圆柱体[216, 539, 1163], 圆锥体[539, 1164], capsule(一个圆柱体有球形柱帽), 以及lozenge(一个box有圆柱的边和球形的角)[294].

</ul>

<h2 id="toc_1.7">16.7 Ray/Box Intersection</h2>
<ul>
<li>
下面给出三个方法用于确定一个ray是否和一个实心box相交. 首先处理的是 AABBs和OBBs, 第二个通常更快些, 但是只处理更简单的AABB, 第三个为页面731基于单独的轴测试, 以及只处理线段与AABBs, 这里我们使用来自章节16.2的定义和符号.

</ul>

<h3 id="toc_1.7.1">16.7.1 Slabs Method</h3>
<ul>
<li>
用于ray/AABB 相交的一个方案其基于 Kay and Kajiya's slab method[480, 639], 其依次由Cyrus-Beck line clipping 算法[217]得到灵感.

<li>
我们扩展这个方案以处理更通用的OBB体, 其返回最近的正t值(也就是, 从ray原点0到相交点的距离, 如果存在的话). 在我们发表这个通用情况之后我们将处理对于AABB的优化. 可通过计算用于该ray和所有沿着这些OBB面的平面. 所有t值来解决该问题. 该box可看成为三个slabs的集合. 见图16.7左部分在二维中的描述. 对于每个slab, 都有个最小和最大t值, 可称之为 TiMIN, TiMAX, 其中i属于(u, v, w). 下一步是计算公式16.14中的变量.

<ul>
<li>
公式16.14

<li>


<li>


</ul>
<li>
现在, 进行一个聪明的测试: 如果 Tmin &lt;= Tmax, 则该ray相交Box; 否则, ray和Box不相交. 

<li>
接下来在一个OBB(A)和一个ray之间用于 ray/OBB 相交测试的伪代码. 该代码返回一个布尔值表示ray是否和BOX相交(INTERSECT 或 REJECT), 以及到交点的距离(如果存在的话). 回忆OBB A, 其中心记为Ac, Au, Av, Aw为box单元化的面法线. Hu, Hv, 以及Hw为正的半长(从中心到box的面).

<li>
伪代码诠释: 第七行检察该ray的方向不垂直于当前测试slab的法线方向, 换句话, 其测试该ray是否平行于slab平面. 其中ε为一个非常小的数. 其阶为10的负二十次方. 简单地避免当除法发生时产生溢出. 行8和行9显示了对f的除法. 实际上, 一次计算出因子1/f而后乘以该值更快. 行10确保t1为最小值. 如果行13返回, 则该ray没有和box相交, 如果行14返回, 表示该box在ray原点之后. 行15表示如果该ray平行于该slab, 测试该ray是否在slab之外. 如果在其外, 则该ray不和box相交. 为了更快的代码, Haines讨论了一种方法解开该循环(loop), 从而避免某些代码.

<li>
这里有另外的测试可利用, 其不在伪代码中. 我们定义了一个ray, 通常想发现最近的物体, 在第15行之后, 我们可以测试 Tmin是否 &gt;= l, l为当前的ray长度. 如果新的相交不更近, 则reject该相交. 可以推迟这个测试直到整个 ray/OBB测试完成, 但其用于循环中一个初期rejection的尝试常常更有效率.

<li>
这里有其他用于OBB特殊例子AABB的优化. 行5, 行6修改为 e = Pi, f = Di, 其使得测试更快. 通常 Amin 和 Amax 用在行8和行9, 所以可以避免额外的加法和减法. Kay and Kajiya[639] and Smits[1200]注意到可以通过允许除0以及正确地翻译处理器的结果来避免行7. Williams[1352]提供了正确处理除0的实现细节, 以及其他的优化. Woo[1373]介绍了一个优化, 其只是再次鉴定和再次三个候选的平面.

<li>
一个slabs方法的概括可用于计算ray与k-DOP, 平截头体, 以及任意复杂多面体的相交; 代码网络可用[481].

</ul>

<h3 id="toc_1.7.2">16.7.2 Line Segment/Box Overlap Test</h3>
<ul>
<li>
本章节则显示页面731上单独的轴测试, 其可用于确定一个线段是否和一个AABB重叠[454]. 相对于一个ray, 线段其有有限的长度. 假设线段定义为一个中点 c, 和一个半向量w. 而AABB则记为B. 可以变换线段, 使得AABB的原点为(0, 0, 0). 其大小为(2Hx, 2Hy, 2Hz). h为box的半向量. 可见图16.8. 

<li>
首先测试三个轴, 由于线段不包含面, 所以其不生成任何测试, 该box则生成三个轴用于测试: (1, 0, 0), (0, 1, 0), 以及(0, 0, 1). 最终, 测试从线段方向与box轴的叉乘形成的轴.

<li>
该测试用于轴(1, 0, 0), 显示如下, 如图16.8所示, 其他的两个轴类似:

<ul>
<li>
公式16. |Cx| &gt; |Wx| + Hx.

<li>
如果这个测试为真, 则线段和该box不重合(overlap).

</ul>
<li>
测试叉乘的轴 a = w x (1, 0, 0) = (0, Wz, -Wy) 如下, 该box的extent投影至 a 上为 Hy|Wz| + Hz|Wy|. 接下来我们需要发现线段的投影长度, 以及线段中心的投影. 线段方向 w 到 a 上的投影为0, 这是由于 w*(w x (1, 0, 0)) = 0. c 到 a 的投影为 c*a = c*(0, Wz, -Wy) = CyWz - CzWy. 因此, 可以参考图16.8的右图, 这个测试成为如下:

<ul>
<li>
公式16.17

</ul>
<li>
再一次, 如果这个测试为真, 则没有重合(overlap). 其他两个叉乘类似.

<li>
程序总结如下

<ul>
<li>
伪代码

</ul>
<li>
按照该代码, 这个程序很快, 但是其有缺点, 不能够返回相交的距离.

</ul>

<h3 id="toc_1.7.3">16.7.3 Ray Slope Method</h3>
<ul>
<li>
在2007年中, Eisemann[301]发表了一个boxes相交的方法, 其比之前的方法更快. 不再进行一个三维的测试, 取而代之为在二维中与box的三个投影(projection)进行测试. 其关键思想为, 对于每个二维的测试, 两个box的角定义了ray所"看到"的极值, 与一个模型轮廓边缘类似, 其与box的投影相交. 该ray的slope必为ray原点和这些两个点定义的两个slope之间. 如果该测试在所有三个投影上通过, 则该ray必然击中该box.  这个方法非常地快, 这是因为某些比较terms完全地依赖于该ray的值. 通过计算这些terms一次, 该ray可以有效率与大数量的boxes比较. 这个方法可以仅返回该box是否击中, 或者也可以一点额外的代价返回相交的距离.

</ul>

<h2 id="toc_1.8">16.8 Ray/Triangle Intersection</h2>
<ul>
<li>
在实时的图形库和APIs中, 三角形几何常被存储为一个带法线的顶点集合, 以及每个三角形由三个这样的顶点定义. 三角形所在平面的法线通常不被存储, 如果需要的时候才会计算. 这里存在许多不同的ray/triangle相交测试, 以及它们之间有许多首先计算ray和三角形平面的相交点. 之后, 相交点和三角形顶点投影到轴对齐的平面(xy, yz, 或者 xz)平面, 选择其中最大的三角形面积. 通过执行这个, 我们将问题降级到二维问题, 以及我们需要做的仅为确定该(二维)点是否在该(二维)三角形中. 存在一些类似的方法, 以及它们被Haines[482]review以及比较, 网上有其可用代码. 见章节16.9使用该技术用于一个流行的算法. 赋值大量的算法用于不同的CPU架构, 编译器, 以及 hit ratios[803], 以及不可能有用于所有情况的单个最好的测试.

<li>
这里, 算法的重点为不假定法线为预先计算的. 对于三角形meshes, 其可以合计了显著的内存节省, 以及动态几何体. 我们不需要重计算任意额外的数据, 诸如每帧三角形的平面公式. 这个算法以及其优化可见 Moller 以及 Trumbore[890]的讨论, 还有他们用于这里的报告(presentation). 还有值得注意的是, Kensler and Shirley[644]注意到大多数的 ray-triangle 测试直接在三维重操作其为计算等价的. 他们开发了使用SSE的新测试用于测试4个rays与一个三角形, 以及使用一个遗传算法以发现这个等价测试中该操作的最好顺序. 在其论文中可见用于该最好性能测试(best-performing)的代码.

<li>
来自共16.1的ray用于测试由三个顶点p1, p2, p3所定义三角形的相交测试.

</ul>

<h3 id="toc_1.8.1">16.8.1 Intersection Algorithm</h3>
<ul>
<li>
给出由显式公式所定义三角形上的一个点, f(u, v)

<ul>
<li>
公式 16.19	f(u, v) = (1-u-v)P0 + uP1 + vP2

</ul>
<li>
(u, v)为两个重心的坐标, 其必须满足 u &gt;= 0, v &gt;= 0, u+v &lt;= 1. 注意(u, v)可用于纹理映射, 法线插值, 颜色插值等. u, v用于表示每个顶点对一个特定的位置所做的贡献. w = (1-u-v)为第三个个权重. 见图16.9.

<li>
计算ray, r(t), 与三角形f(u, v)的相交, 其等价于 r(t) = f(u, v), 其产生:

<ul>
<li>
公式16.20 

</ul>
<li>
重新整理该公式则有

<ul>
<li>
公式16.21

</ul>
<li>
这意味着可通过解决该公式的线性系统来发现重心坐标(u, v)以及从ray原点到交点的距离t.

<li>
上面公式的操作可看成: 平移三角形至原点, 且变换该三角形, 使得其在y和z中为一个单元三角形, 以及该ray的方向与x对齐. 具体可见图16.10中的阐明. 如果矩阵为 M = (-d  p1-p0  p2-p0)为公式16.21中的矩阵, 此时可通过乘以公式16.21的M的负一次方来发现其解决方案

<li>
记 e1 = p1 - p0, e2 = p2 - p0, s = o - p0. 则公式16.21的解从Cramer's rule得到:

<ul>
<li>
公式16.22

<li>


<li>


</ul>
<li>
从线性代数可知, det(a, b, c) = |a b c| = -(axc)・b = (cxb)・a. 公式16.22可重写如下:

<ul>
<li>
公式16.23

<li>


<li>


</ul>
<li>
其中 q = dxe2, r= sxe1. 这些因子可用于加速计算. 

<li>
如果你提供额外的存储, 则可重新形成该测试以减少计算的数量. 公式16.23可重写如下

<ul>
<li>
公式16.24

<li>


<li>


<li>


<li>


<li>


</ul>
<li>
其中 n = e1xe2, 其为三角形上未单元化的法线, 因此为常量(对于静态几何体). 以及 m = sxd. 如果我们存储p0, e1, e2以及n用于每个三角形, 则我们可以避免许多的用于ray triangle相交的计算. 大多数的节省从避免叉乘得来. 	

</ul>

<h3 id="toc_1.8.2">16.8.2 Implementation</h3>
<ul>
<li>
该算法可以概括为如下的伪代码, 其除了返回ray是否和三角形相交之外, 该算法还返回之前描述的三元组(u, v, t). 这个算法并没有剔除背面的三角形, 以及还返回负的t值相交.

<li>
行4计算出来的a, 其为矩阵M的行列式. 接下来的测试避免行列式为0. 第九行, u值和三角形中u为0的边进行比较.

<li>
该算法的C语言版本, 包括culling和non-culling的版本, 网络上可用[890]. C代码有两个转移(branch), 一个有效率的剔除所有背面三角形, 一个执行两面三角形的相交测试. 所有的计算都延迟至要求的时候. 例如, 不计算v值直到u值发现在允许的范围之内(具体可见伪代码).

<li>
一面的相交程序其消除了所有行列式为负的三角形. 这个程序允许程序仅有的除法操作延迟到相交被确认的时候才执行.

</ul>

<h2 id="toc_1.9">16.9 Ray/Polygon Intersection</h2>
<ul>
<li>
n个顶点的多边形由一个有序的顶点列表{V0, V1, ..., Vn-1}定义, 顶点Vi和顶点Vi+1形成一条边. (i为从0到n-1的整数). 多边形为封闭多边形. 所在平面定义为 πp: Np・x + Dp = 0. 

<li>
我们首先计算ray和 平面πp之间的相交, 可以简单的替换x为ray的方程, 表示如下:

<ul>
<li>
公式16.26

<li>


<li>


</ul>
<li>
如果 |Np・d| &lt; ε, 其中ε为一个很小的书, 则该ray可以看成平行于多边形平面, 没有相交发生. 否则可以计算出相交的点 p = O + td. 而后的问题就是确定点p是否在多边形内, 这个问题从三维难度降低到二维难度. 投影多边形所有的顶点和p到xy, xz, yz平面, 选择其中投影多边形面积最大的一个. 换句话, 坐标成员对应于max(|Np, x|, |Np, y|, |Np, z|)---法线的那个可以略过, 剩下的两个成员则作为二维的坐标. 例如, 给定法线(0.6, -0.692, 0.4), 则略过y成分. 注意为了效率, 这个成员信息可以与计算一次且存储在多边形中. 多边形的拓扑(topology)和相交点在投影中仍保持(假设多边形确实为平的, 具体可见章节12.2该主题更多的信息). 投影的程序可见图16.22所示.

<li>
剩下的问题就是相交点p投影的点是否在多边形的投影内. 这里我们复习一一个有用的算法----the "crossings" test. Haines[482], Schneider and Eberly[1131]提供了二维point-in-polygon策略的扩展的survey. 更正式的处理可见计算几何文献[82, 975, 1033]. Lagae和Dutre[711]提供一个更快的方法用于 ray/quadrilateral 相交, 这个基于 Moller 和 Trumbore 的 ray/triangle 测试. Walker[1315]提供了一个方法用于快速测试多于10个顶点的多边形. Nishita[936]则讨论用于曲边形状的point inclusion test(点包含测试--点是否包含在多边形内).

</ul>

<h3 id="toc_1.9.1">16.9.1 The Crossing Test</h3>
<ul>
<li>
该 crossing test 基于 Jordan Curve Theorem. 来自于拓扑学的一个结果, 如果一个点在一多边形内, 该点以一个任意的方向发射一ray, 则会通过奇数数量的多边形的边. 该Jordan Curve Theorem限制了自身为 non-self-intersecting loops. 对于self-intersection loops, 该ray测试会导致某些看起来在多边形内的区域看成在多边形之外. 这个可见图16.12. 这个测试也称为 parity 或者 the even-odd test.

<li>
该 crossing 算法其为最快的测试, 而无需预计算. 通过投影的点p沿着正x轴方向发射一条ray, 而后计算多边形边与该ray相交的数量. 如果数量为奇数, 则其为多边形内的点.

<li>
测试的点p可看成原点, 而(平移的)多边形边则测试正的X轴. 具体可见图16.13. 如果一多边形边其y轴为相同的符号, 则该边不与x轴相交. 否则检查其x坐标, 如果都为正, 则相交数加一. 如果符号不同, 则必须计算该边与x轴相交的x坐标. 如果该x坐标为正, 则相交数加一.

<li>
还可包含一个enclosed area. 这个变种的测试查找其winding number. 即该测试点周边多边形循环的次数. 具体可见Haines[482]的处理.

<li>
当该测试和一个顶点相交的时候会出现问题, 由于可能检测出两个相交.通过设置该顶点无限小地在ray之上来解决该问题. 实际上, 所有y&gt;=0的顶点都被解释为在x轴之上. 这个代码则变得更简单和更快, 且没有任何顶点会被相交.

<li>
用于crossing test的效率形式的伪代码如下, 灵感来自 Joseph Samosky[1101]和Mark Haigh-Hutchinson的著作, 代码网上可用[482]. 二维的测试点t和多边形P, 以及比较顶点V0到Vn-1.

<li>
行3其测试多边形中最后一个顶点的y值是否大于或等于测试点t的y值, 并将结果存储在布尔类型的y0中. 换句话, 我们要测试的第一条边的第一个端点是在x轴之上还是之下. 而行7则测试断点e0和e1是否在测试点所形成x轴的两边. 如果是, 则行8测试x轴上的截点是否为正. 这里有更好的技巧, 为了避免计算截点通常所需要的除法, 我们这里执行一个 sign-canceling 操作. 通过内部反转, 行9记录了一个crossing发生. 行10到行12移到下一个顶点.

<li>
伪代码中, 我们在行7后并不执行一个测试, 以查看两个端点有比测试点更大或更小的x坐标. 虽然我们发表了算法使用快速的accept或reject这些类型的边, 代码基于上面以列出的伪代码, 其运行常常由于没有这个测试而更快. 其中一个主要因素为测试的多边形中顶点的数量. 在测试中, 检查x坐标符号的不同, 当测试的多边形其顶点数多于10个到30个, 开始pay off(得到好处). 其有足够的边从一开始的rejection 或 acceptance 获得好处, 以及在行8上要求更少的完全测试. 即是说, 1000个顶点的多边形可以获得整体性能至多16%的提升.

<li>
这个crossing test相对地快和健壮. 缺点是该方法不生成除了测试点在多边形内外之外的信息.

</ul>

<h2 id="toc_1.10">16.10 Plane/Box Intersection Detection</h2>
<ul>
<li>
确定一个box是否和一个平面 πp: Np・x + Dp = 0 相交, 插入该box的所有顶点到该平面公式, 如果正的和负的(或零的)结果都能得到, 则该box的顶点位于该平面的两边, 因此可检测到box与plane相交. 这里有更聪明更快的方法完成这个测试, 发表于之后的两个章节, 一个用于AABB, 一个用于OBB.

<li>
其背后的思想为仅有两个顶点需要插入到平面公式中. 对于一个任意朝向的box, 无论是否与平面相交, 当沿着平面的法线测量时, 其有两个斜对的角相隔最长的距离. 每个box有4个对角线, 每个对角线向量与平面法线点乘, 其最大值标识出两个最远点所形成的对角线. 通过测试这两个角, 整个box就可作为一个整体与平面测试.

</ul>

<h3 id="toc_1.10.1">16.10.1 AABB</h3>
<ul>
<li>
假设有一个AABB, B, 其有一个中点 c, 正的半对角向量, h, 注意c和h可以轻易地被最小和最大的角推导出来. c = (Bmax + Bmin)/2, h = (Bmax - Bmin)/2.

<li>
现在我们想要测试B与平面 Np・x + Dp = 0 的相交, 这里有惊人快速的方法执行测试. 其思想为当box投影到平面法线n, 计算其"extent", 记为e. 理论上, 可以通过投影八个不同的半对角线到该法线上, 并拾取其中最大的那一个. 实际上, 可以使用下面的公式快速地实现:

<ul>
<li>
公式16.28

<li>


</ul>
<li>
一段证明.

<li>
接下来我们计算有符号的距离, s, 从中点c到平面的距离. s =c・n + d. c和e可见图16.14所示. 假设平面的"外面"为正的半空间, 简单的测试 s-e&gt;0, 表示 box 完全在平面之外. s+e &lt;0 则表示box完全在平面之内. 除此之外, 平面与box相交. 这个技术基于Ville Miettinen 以及他的聪明实现的思想[864]. 伪代码可见书本.

</ul>

<h3 id="toc_1.10.2">16.10.2 OBB</h3>
<ul>
<li>
其测试与AABB/plane测试有轻微的不同. 只有box"extent"的计算需要改变, 改变为下面的公式:

<ul>
<li>
公式 16.29

<li>


</ul>
<li>
其中 (Bu, Bv, Bw)为OBB坐标系的轴, (HuB, HvB, HwB)则为box沿着这些轴的长度.

</ul>

<h2 id="toc_1.11">16.11 Triangle/Triangle Intersection</h2>
<ul>
<li>
这个问题为: 给定两个三角形, T1 = △p1q1r1 和 T2 = △p2q2r2(分别在平面π1和平面π2上), 确定它们是否相交.	

<li>
这里我们发表一个方法称之为 interval overlap test, 由Moller[891]介绍, 其比使用SAT更快. Guigue and Devillers[467]则提出进一步的优化, 使得算法更加健壮. Shen[1162]以及Held[539]提出了类似的测试. 不同的架构以及编译器, 还有预期hit ratio的变种, 使得很难挑选出一个算法为执行最好的算法.

<li>
从高层中, 首先检查T1是否相交于平面π2, T2是否相交与平面π1, 如果测试都失败, 则两者不相交. 假设三角形不共面, 我们知道两个平面的相交会有一条线, L. 具体可见图16.15. 在该图中可看出, 如果三角形相交, 则它们在L上的相交会重合. 否则他们没有相交. 有不同的方法实现这个, 这里我们介绍Guigue和Devillers[467]的方法.

<li>
在这个实现中, 其大量的使用4x4行列式, 这个矩阵由4个三维向量组成, a, b, c, d. 见下面的公式:

<ul>
<li>
公式16.31

<li>


<li>


<li>


<li>


</ul>
<li>
可以理解成三角形abc的法线与d-a的点乘. 如果d在abc平面的上方则为正. 另一种解释为, b-a向量方向其旋转的方向与d-c相同则为正. 这个可见图16.16.

<li>
现在, 对于 interval overlap 方法, 我们首先开始测试T1与平面π2的相交情况, 以及T2与平面π1的相交情况. 我们可以通过赋值[p2, q2, r2, p1], [p2, q2, r2, q1], 以及 [p2, q2, r2, r1]从公式16.31中使用专门的行列式来完成这个. 第一个测试等价于计算T2的法线以及测试点p1在哪个半空间里. 如果这些行列式的符号相同且非零, 则没有相交. 此时测试结束. 如果都为零, 则三角形共面. 对于这种情况执行单独的测试. 否则, 我们使用相同类型的测试继续测试T2与π1的相交情况. 

<li>
Guigue 和 Deviller 假设三角形没有一个顶点或者一条边刚好在另一个三角形所在的平面上. 如果发生这种情况, 其用这样的方法perturb顶点以便保存其与L的相交. 这个算法此时通过改变三角形顶点的顺序使得 p1(p2)为在那个半空间中唯一的顶点. 同时, 交换其他的顶点(q2和r2), 使得p1以逆时针的顺序"看"顶点p2, q2, r2(对于p2同样类似). 在图16.17中可以看到以这种方式安排顶点的顺序. 让我们记L上的标量相交为i, j, k, l. 其用于边 p1q1, p1r1, p2q2, 以及 p2r2. 这个也可以看图16.17. 这些标量形成两个间隔, I1 = [i, j], I2 = [k, l], 如果 I1 和 I2重合, 则两个三角形相交. 以及这个仅发生在 k &lt;=j, 其 i &lt;= l的时候. 为了实现 k &lt;= j, 我们可以使用行列式的 sign test(公式16.31), 以及注意p1r1推导(derive)出j, p2q2推导出k. 使用行列式计算的"screw test"的解释, 我们可以得出结论如果[p1, q1, p2, q2] &lt;= 0 则 k &lt;= j,, 最后的测试变成如下:

<ul>
<li>
公式16.32

<li>


</ul>
<li>
整个测试开始于六个行列式测试, 以及前三个共享第一个参数, 原则上, 可以使用更小的2x2子行列式计算该行列式, 则其计算可以共享. 网上有用于该测试的代码[467]. 还可以扩大该代码以计算相交的实际线段.

<li>
如果三角形共面, 它们则投影至轴对齐的平面, 取其中投影面积最小的平面(见章节16.9). 此时则执行一个简单的二维三角形重叠测试. 首先测试T1所有的封闭边(包括端点)与T2的封闭边的相交情况. 如果有相交发生, 则两个三角形相交. 否则, 我们测试三角形T1是否完全包含在T2内, 或者相反. 这个可以通过执行 point-in-triangle 测试完成(见章节16.8).

<li>
当三角形接近于共面, 或者一条边接近于与另一个三角形共面, 则会有健壮度问题(特别当一条边靠近另一三角形一条边的时候). 处理这个问题可以用一个用户定义的常量, EPSILON(ε), 如果|[p2, q2, r2, p1]| &lt; ε, 则移动p1使得[p2, q2, r2, p1] = 0. 几何上, 意味着如果一个点与另一个三角形平面"足够近", 则可认为其在该平面上. 同样可用于其他三角形的该点. 源代码不处理退化三角形(也就是, 线和点). 为了执行这个, 首先检测这些情况, 而后处理为特殊情况.

</ul>

<h2 id="toc_1.12">16.12 Triangle/Box Overlap</h2>
<ul>
<li>
Green and Hatch[441]发表了一个算法可以确定一个任意的多边形是否和一个box重合. Akenine-Moller[11]则开发了一个更快的方法, 其基于单独的轴测试(页面731), 本章节即介绍这个方法.

<li>
我们关注于轴对齐的围绕盒(AABB), 由一个中点c和一个半长向量h所定义. 我们首先移动该box和三角形, 使得该box中心位于原点. 即, vi = ui - ci, i为0, 1, 2. 这个变换和记号可见图16.17. 对于一个有朝向的(oriented)box, 我们首先通过相反的box变换旋转三角形的顶点, 而后使用测试.

<ol>
<li>
[3 tests] e0 = (1, 0, 0), e1 = (0, 1, 0), e2 = (0, 0, 1)(AABB的法线). 换句话, 测试AABB与围绕三角形最小的AABB.

<li>
[1 test] n, △u0u1u2的法线. 我们使用一个快速的平面/AABB重合测试(见章节16.10.1), 我们只测试最靠近对齐三角形法线方向的box对角线上的两个顶点.

<li>
[9 tests] aij = ei x fj, i,j∈{0, 1, 2}, 其中 f0 = v1 - v0, f1 = v2 - v1, f2 = v0 - v2. 也就是边向量. 这些测试非常类似, 且我们只显示i=0和j=0这个情况的推导.

</ol>
<li>
一旦找到一个separating axis, 则该算法终止且返回"没有重叠". 如果所有测试通过, 也就是, 没有separating axis, 则该三角形重合box.

<li>
这里我们推导九个测试中的一个, 当i = 0, j = 0. 第三步中, 则意味着 a00 = e0 x f0 = (0, -F0z, F0y), 所以, 现在我们需要投影该三角形顶点到a00上(后面(hereafter)调用 a)

<ul>
<li>
公式16.33

<li>


<li>


<li>


<li>


</ul>
<li>
通常, 我们需要发现 min(p0, p1, p2)以及 max(p0, p1, p2), 但幸运的是, p0 = p1, 其可简化计算. 现在我们只需要发现 min(p0, p2) 以及 max(p0, p2), 这是由于在现代CPU上条件语句很昂贵, 所以节省计算可以导致其更快.

<li>
在三角形投影至a之后, 我们还需要将box也投影到a上. 我们计算一个"半径", r. 其为box投影在a上的半径.

<ul>
<li>
公式 16.34

<li>


<li>


</ul>
<li>
最后一步的简化是因为 Ax = 0. 此时, 测试如下:

<ul>
<li>
公式 16.35

<li>


</ul>
<li>
代码网上可用[11].

</ul>

<h2 id="toc_1.13">16.13 BV/BV Intersection Tests</h2>
<ul>
<li>
Bounding volume hierarchies 常为碰撞检测算法基础的一部分(见第17章). 四个常用的围绕体分别为球体, AABB, k-DOP, OBB.

<li>
还可使用其他的BV, 例如圆柱体, 椭圆体, capsules等.

</ul>

<h3 id="toc_1.13.1">16.13.1 Sphere/Sphere Intersection</h3>
<ul>
<li>
计算方法很简单, 计算两个球心的距离是否大于两个球体的半径之和. 该算法使用距离的平方进行比较. Ericson[315]则给出了SEE代码用于同时测试四个不同对的球体.

</ul>

<h3 id="toc_1.13.2">16.13.2 Sphere/Box Intersection</h3>
<ul>
<li>
Arvo[34]提出一个算法测试AABB与一个球体的相交. 其思路为查找AABB上最靠近球心的点. 使用一维测试, 测试AABB的三个轴. 对于每个轴, 都测试球心在该轴方向量与AABB其bound的关系. 如果球心该坐标分量在AABB之外, 则计算球心在该轴方向上到box的距离, 并且平方之. 我们在三个轴都如此操作. 则这些平方距离的和与半径r的平方相比较. 如果小于r的平方, 则最近的点在球体内, 该球与该box相交. 正如Arvo所显示, 该算法可以修改为处理中空的box和球体, 以及轴对齐的椭圆球体.

<li>
Larsson[734]发表了该算法的一些变种, 包含了显著地更快的SSE矢量化(vectorized)版本. 他们在初期使用简单的rejection测试. 该测试查看center-to-box的距离在该轴上是否大于半径. 如果是, 则停止测试, 球体不可能和box相交. 下面为他们测试的QRI(quick rejections intertwined)版本. 提前退出的测试代码位于行4和行7, 可以根据需要移除这代码.

<ul>
<li>
伪代码

</ul>
<li>
对于快速的矢量化(使用SSE)实现, Larsson等提出了消除主要的branches. 其使用接下的表达式同时赋值行3和行6:

<ul>
<li>
公式16.38

<li>


</ul>
<li>
通常我们更新d为 d = d + e^2. 但是我们使用SSE可以并行赋值公式16.38用于x, y, z. 给出用于完全测试的伪代码如下:

<ul>
<li>
伪代码

</ul>
<li>
注意行1和行2可以使用一个平行的SSE max函数实现, 即使没有在该测试中早期退出, 其仍比其他的技术更快, 这是由于消除了branches以及使用并行的计算.

<li>
对于SSE的另一个方法为矢量化物体对, Ericson[315]提出了SIMD代码用于同时比较四个球体和四个AABB.

<li>
对于 sphere/OBB 相交, 首先变换球心到OBB的空间, 即使用OBB的单元化的轴作为基坐标来变换球心. 而后OBB可看成AABB, 此时可用sphere/AABB算法来出相交测试. 

</ul>

<h3 id="toc_1.13.3">16.16.3 AABB/AABB intersection</h3>
<ul>
<li>
两个点足够描述AABB这样的BV. 这里我们使用章节16.2所发表的AABB定义.

<li>
由于它们的简单, AABB通常用于碰撞检测算法和用于场景图中节点的围绕体. 两个AABB之间的测试, A与B, 为琐碎的以及总结如下:

<ul>
<li>
伪代码

</ul>
<li>
代码行1和行2循环所有三个标准轴方向 x, y, z. Ericson[315]提出SSE代码用于同时测试四个单独的AABBs对.

<li>
SSE的另一个方法为矢量化物体对. Ericson[315]发表了SIMD代码用于同时比较四个球体和四个AABBs.

</ul>

<h3 id="toc_1.13.4">16.13.4 k-DOP/k-DOP intersection</h3>
<ul>
<li>
这个围绕体称之为 discrete orientation polytope 或者 k-DOP, 由Klosowski命名[672]. 一个k-DOP为一个凸多面体. 由k法线的小且固定的集所确定的面. 该法线向外的半空间不被认为BV的一部分. Kay and Kajiya首先介绍这个类型的BV. 在ray-tracing的上下文中使用它们. 同样, 它们称相反方位法线的两个平行平面之间的空间体为bounding slab, 以及使用它们保证相交的代价降低(见章节16.7.1). 因为相同的原因, 这个技术也用于k-DOPs. 作为一个结果, 相交测试仅有 k/2个间隔重合(interval overlap)测试组成. Klosowski[672]显示了, 对于k这个moderate值, 两个k-DOPs的重合测试为一个比两个ODD测试更快量级的命令. 在页面730的图16.4中, 描述了一个简单的二维k-DOP. 注意AABB为一个6-DOP的特殊情况. 注意, 随着k的增加, BV更像一个凸包(convex hull), 其为最紧贴适应的凸BV.

<li>
如果两个k-DOPs, A和B(下标表示A和B), 测试它们的相交. 则测试他们所有的slabs对(SiA, SiB)的重合. Si = SiA和SiB之间的交集. 其为一维的间隔重合测试. 如果任意时候, Si = 空集. 则BV不相连, 终止测试. 否则, 继续slab重合测试. 当且仅当所有的 Si不等于空集, 且 1 &lt;= i &lt;= k/2, 则BV可看成重合的. 根据单独的轴测试(见章节16.2), 其中一个也要测试一个轴平行于一条边来自于每个k-DOP的叉乘. 然后这些测试常被略过, 这是由于他们代价在性能上更高. 因此, 如果下面的测试返回k-DOP重合, 它们则有可能为不连接的. 这里有用于 k-DOP/k-DOP重合测试的伪代码:

<li>
注意到k个标量值需要与k-DOP的每个instance一起被存储(法线, Ni, 对于所有的 k-DOPs 只存储一次, 这是由于它们为静态的). 如果由tA和tA来各自平移(translate)k-DOPs这个测试则有点复杂. 投影 tA到法线上, Ni. 也就是 PiA = tA・Ni, (注意其独立于任意的k-DOP以及对每个tA或者tB需要仅计算一次)以及在条件语句中添加PiA到DiA,max上. 这个同样用于tB. 换句话, 平移改变了k-DOP沿着各个法线方向上的的距离.

</ul>

<h3 id="toc_1.13.5">16.13.5 OBB/OBB Intersection</h3>
<ul>
<li>
OBB的定义见章节16.2, 两个OBB, 分别为A和B. 

<li>
这个测试使用A的中心为原点, A的三个轴为坐标系轴. B则通过平移t和旋转(矩阵)R移动到A的坐标系空间中.

<li>
根据单独的轴测试, 其能够发现一个轴分开A和B确保它们为不连接的(不重合的). 测试15个轴, 3个来自A的面, 3个来自与B的面, 3・3 = 9. 见图16.20的二维显示. 作为矩阵 A = (Au, Av, Aw)正交化的结果, 可能的分开轴应当与平面正交, 其为简单的轴Au, Av, Aw. 这一点同样用于B. 所以九个可能的轴由A和B的各一条边组成, Cij = Ai x Bj. 

<li>
假设一个可能的分开轴为s, 采用图16.21中的记号. 使用OBB在s上的"半径", dA和dB, 其通过投影可得. 见公式16.42表达. 记住 HiA和HiB为正, 故不需要计算其绝对值.

<ul>
<li>
公式16.42

<li>


<li>


<li>


<li>


<li>


<li>


</ul>
<li>
当且仅当, s为separating axis时, 该轴上的间隔应当为不连接的. 接下来应有:

<ul>
<li>
公式 16.43

<li>


</ul>
<li>
对于公式16.43接下来三种情况的推导和简化可见如下, 三种情况分别为 A的边, B的边, 来自A和B的边的组合.

<li>
首先, 假设 s = Au, 则给出表达式如下:

<ul>
<li>
公式16.44

<li>


</ul>
<li>
在公式16.45中, 用于dA和dB的表达式可简化:

<ul>
<li>
公式 16.45

<li>


<li>


<li>


<li>


<li>


</ul>
<li>
注意其中B的矩阵如下:

<ul>
<li>
公式16.46

<li>


<li>


<li>


</ul>
<li>
则对于 l = Au 的不连接测试如下:

<ul>
<li>
公式 16.47

<li>


</ul>
<li>
如果上面表达式为真, 则A和B不相连. s=Av和s=Aw类似的测试表达式还可推导出.

<li>
其次, 假设 s= Bu, 则推导如下:

<ul>
<li>
公式 16.48

<li>


<li>


<li>


<li>


<li>


<li>


<li>


<li>


</ul>
<li>
对于s=Bu的不连接测试如下:

<ul>
<li>
公式 16.49

<li>


</ul>
<li>
对于剩下的轴 Bv和Bw可以以同样的方式推导.

<li>
最后, 测试两个OBB边的组合作为separating axis. 例如取 s = AuxBu. 则有推导公式16.50, 具体见书本

<li>
最后的测试如下

<ul>
<li>
公式 16.51

</ul>
<li>
剩下的轴 Cij = Ai x Bj, 其中i, j为 u, v, w. 都按照这样的方式推导出测试. 

<li>
如果15个测试任意一个都为正的, 则OBB不相交. 当OBBs重合的时候则有最大的操作数量(180或240个--如果包含变换B到A坐标空间的操作). Gottschalk[433]则指出R中元素的绝对值被使用四次, 因此可计算一次绝对值而后重用它用于更快的代码. 

<li>
注意, 以不同的顺序测试轴会影响其性能. 先测试Au, Av, Aw, 其次 Bu, Bv, Bw, 而后是两者的叉乘.

<li>
在OBB/OBB测试之前可以使用一个快速测试, 设置一个封装球体, 球心位于OBB的中心, 半径由Hu, Hv, Hw计算出来, 而后进行球与球的相交测试.

</ul>

<h2 id="toc_1.14">16.14 View Frustum Intersection</h2>
<ul>
<li>
查看为什么我们需要三个返回值 outside/inside/intersect, 我们将检查当遍历围绕体层体系时发生了什么. 如果一个BV被发现完全在view frustum之外时, 则该BV的子树不需要进一步遍历, 它之内的几何体不会被渲染. 另一方面, 如果BV完全在之内, 则不需要对其子树进行 frustum/BV计算, 其每个可渲染的叶子都会被绘制. 对于部分可见的BV, 即与view frustum相交的BV, 递归测试该BV的子树与frustum. 如果BV为叶子, 则必须渲染该叶子.

<li>
该完整的测试称之为 exclusion/inclusion/intersection test. 有时候, 第三个状态, intersection, 计算其代价太高. 所以该BV归类为"probably-inside". 此时我们则简化算法为 exclusion/inclusion test. 如果一个BV不能成功地派出出外, 则有两个选择, 一个看成 "probably-inside"状态为一个inclusion. 即意味着每个BV内的物体都被渲染, 这是无效率的行为. 另一个选择是测试子树内的每个节点依次查看其是否在frustum外部. 如果其内每个物体都在frustum内部, 则该选择不是好选择. 由于所有的选择都不特别好, 因此某些尝试快速地区分相交和包含(inclusion)的做法是值得的, 即使该测试不完美.

<li>
意识到快速分类测试(quick classification test)并不精确地用于场景图culling, 其为保守的, 意识到这点很重要. 对于从inclusion中区分出exclusion, 其所要求的为在inclusion这边(side of)上的测试错误(test err). 另一方面, 应当被包含的(included)物体从不被快速地被测试分类为excluded, 否则会发生渲染错误. inclusion相对于intersection, 所有不正确地分类类型都是合法的, 如果一个完全包含在内的BV分类为intersecting, 则其浪费时间测试其子树的相交. 如果一个相交的BV看成完全包含在内的BV, 则浪费时间渲染所有的物体, 其中某些物体应当被剔除. 

<li>
在介绍一个frustum与球体, AABB, OBB的相交之前, 我们将描述一个frustum和一个通用物体之间的一个相交测试, 这个测试在图16.23中测试, 其思想为变换一个BV/frustum测试为一个point/frustum测试. 选择关于BV上的一个点, 则该BV沿着frustum的外边移动, 在没有重合的情况下尽可能地靠近于它. 在移动过程中, 跟踪关于BV的该点, 它的痕迹形成一个新的volume(见图16.23中有粗边的多边形). BV其移动尽可能地靠近frustum则意味着如果关于BV的点(在它原始的位置上)位于traced-out volume内, 则该BV与frustum相交或者在其之内. 所以不再测试BV和frustum的相交, 而是测试相对于BV的一个点与另一个新的volume, 该volume有跟踪该点的痕迹所得. 同样的方式, 该BV在frustum内部移动, 以及尽可能靠近frustum, 这可以跟踪出一个新的, 更小的原始frustum[48]. 其平面平行于原始的frustum[48]. 如果相对于BV的点其原始位置在新的volume之内, 则该BV完全在frustum之内. 这个技术可用于推导出之后章节的测试. 注意, 创建一个新的volume其独立于BV的实际位置. 其仅依赖于BV相对点的位置. 即意味着, 一个有任意位置的BV可以使用相同的volume进行测试, 而无需重新创建.

<li>
首先, 推导出frustum的平面方程. 其用于这类的测试.

</ul>

<h3 id="toc_1.14.1">16.14.1 Frustum Plane Extraction</h3>
<ul>
<li>
为了执行view frustum culling, 需要用于frustum六个不同side的平面公式. 假设视图矩阵为V, 投影矩阵为P. 则有矩阵 M = PV. 有一个点S(Sw=1), 变换为 T = MS. 此时 T可能有 Tw != 1. T中所有成员除以Tw, 使得U有Uw = 1. 对于view frustum之内的点, 有 -1 &lt;= Ui &lt;= 1, 其i为x, y, z. 从这个公式, 可推导出frustum的平面, 显示如下.

<li>
对于frustum左平面的右边, 有 -1 &lt;= Ux, 可推导出如下公式:

<ul>
<li>
公式16.52

<li>


<li>


<li>


<li>


</ul>
<li>
其中Mi, 表示矩阵M的第i行. 注意要使得上面的公式表示一个平面, 且法线朝外, 则需要加上负号, 六个世界空间的平面公式如下:

<ul>
<li>
公式16.53

<li>


<li>


<li>


<li>


<li>


<li>


</ul>
<li>
在OpenGL或DirectX中完成这个的代码可见网上[455].

</ul>

<h3 id="toc_1.14.2">16.14.2 Frustum/Sphere Intersection</h3>
<ul>
<li>
对于正交投影, frustum为一个box, 所以重合测试变成 sphere/OBB 相交测试, 其可以使用章节16.13.2中的算法解决这个问题. 进一步测试以发现该球是否完全在box之内, 我们将该box看成为中空的, 且我们查找最近的点. 	对于该修改算法的完全报告以及代码, 可见Arvo[34].

<li>
接下来的方法用于推倒一个 frustum/BV test. 我们选择球的原点作为要跟踪的点p, 可见图16.24. 如果该半径为r的球沿着frustum内部和外部尽可能近地移动, 则p的痕迹给出一个volume, 该volume其需要重新形成 frustum/sphere test. 实际volume可见图16.24的中间部分. 和以前一样, 如果p在橙色volume之外, 则球在frustum外面. 如果p在紫色区域之内, 则球体完全在frustum内部. 如果点在橙色区域, 则球和frustum的面相交. 以这种方式则可以完成精确测试. 然而, 为了效率, 我们使用近似的方法, 可见图16.24中的右边图. 在这里, 扩展橙色volume以避免更复杂的要求圆角的计算. 注意, 对于outer volume, 他的组成为frustum的平面沿着frustum法线向外移动r个距离单位, 而inner volume则为frustum平面沿着其法线向内移动r个距离单位. 

<li>
假设frustum的平面公式, 其正的半空间位于frustum外部. 此时, 一个实际的实现应当循环在frustum的六个平面上, 以及对于每个frustum平面, 计算球心到该平面的有符号距离. 这通过插入球心到平面公式可得. 如果距离大于半径r, 则该球体在frustum外部, 如果所有六个平面的距离都小于-r, 则该球体完全在frustum内部, 其他情况球体和frustum相交. 为了测试更加精确, 其可能增加额外的平面用于测试球体是否在外部. 然而, 为了快速剔除场景图节点这个目标, 偶尔地false hit其简单地导致了不必要的测试, 而不是算法失败, 以及总的来说该额外的测试会花费更多的时间. 

<li>
大多数frustum相对于view direction对称的, 即意味着左平面为右平面绕着view direction反射而来, 其也用于底部和顶部平面. 对于一个对称的frustum, 为了减少必须测试的平面数量, 可以添加一个octant test到之前的view frustum test[48]. 对于这个测试, 该frustum划分为八个octant, 可见图16.25. 当完成这个, 我仅需要测试三个球心在内的octant的outer plane. 即意味着, 我们可实际上对分需要测试的平面数量. 当其发现该测试并没有提高frustum/sphere测试的性能, 由于sphere/plane测试如此的快, 其可以扩展以及用于抽象的物体(见图16.25的右边). 在下一章节将可见到, 这个测试可用于加速用于AABBs和OBBs的frustum test.

<li>
Bishop[89]讨论了接下来用于在游戏引擎中sphere culling的灵巧优化. 这个有用的技术可应用于任意的hierarchical frustum culling scheme, 而不考虑BV的类型. 如果一个BV其被发现完全在一个确定的frustum平面内, 在它的孩子也在该平面内. 这意味着该平面测试可以忽略其所有的孩子, 其可以导致结果更快的全面测试.

</ul>

<h3 id="toc_1.14.3">16.14.3 Frustum/Box Intersection</h3>
<ul>
<li>
如果view的投影为正交的(也就是, frustum有一个box形状), 则可以使用OBB/OBB相交测试来精确地测试(见章节16.13.5). 对于通用的 frustum/box 相交测试, 则有一个简单地 exclusion/inclusion/intersection 测试为不精确但保守的测试. 该测试类似于frustum/sphere测试, 其就爱你查OBB或者AABB围绕盒与六个view frustum面. 如果所有围绕盒角的点位于一个平面之外, 则该围绕盒在平面之外. 然而, 替换检查所有角的点(最糟糕的情况)即每个平面公式, 我们可使用章节16.10中介绍的更聪明的测试.

<li>
该算法测试依次box与六个frustum平面中的每个. 如果该box在一个平面之外, 则该box位于frustum之外, 且该测试终止. 如果box在所有六个平面之内, 则box在frustum之内. 其他情况为其与frustum相交(即使其有可能稍微地位于外部--见下面).伪代码显示如下, 其中πi, i=0, ..., 5为六个frustum平面, 以及B为该AABB. 正如你所见, 该算法核心为章节16.10的plane/box测试.

<li>
类似于 frustum/sphere 算法, 该测试常分类实际上完全在外部的boxes为相交的box. 这种类型的错误可见图16.26. 一个 exclusion/inclusion 方法其使用separating axis test(章节16.13)到处一个相交程序, 则不会有该问题.

<li>
由于 plane/box 测试比plane/sphare测试昂贵, 所以其常使用章节16.14.2中的octant test以得到改进.  这个可测试可以立即抛弃六个frustum平面中的三个[48]. 其用于近截和远截平面的点乘计算可以共享, 这是由于这两个平面为平行地. 该技术的讨论可见上个章节中, Bishop[89]对于围绕球的优化测试和裁剪也可用于这里. 

</ul>

<h2 id="toc_1.15">16.15 Shaft/Box and Shaft/Sphere Intersection</h2>
<ul>
<li>
法线在两个AABB之间中有何内容有时候很重要. 这个操作对于occlusion culling, 动态相交测试(见章节16.18), 或者光纤传输算法例如radiosity, 都很有用. 两个AABB之间的volume, 包括AABBs自身, 称之为一个shaft, 以及其相交操作称之为 shaft culling. 见图16.27.

<li>
一个shaft实际上有单个大的AABB和n个平面集组成. 每个平面修剪掉AABB上的一部分volume, 以及所有在AABB内和所有平面之内的volume为该shaft. 实际上, 该shaft的AABB可看成一个六平面的集合, 而该shaft则看成n+6个平面的集合. 即为, 该六个平面使得shaft为轴对齐的, 在和其他AABB相交测试时, 可确保没有false hit生成. 

<li>
首先该shaft由两个初始的AABBs组成. 该shaft的AABB为围绕两个初始AABB的最小AABB. 接下来的任务为计算连接两个初始AABB的平面集合. 每个平面相互联系, 并且平行于shaft其AABB十二条边中的一条边. 每个生成的平面其连接(attach)一个初始AABB其十二条边中的一条边至另一个初始AABB对应的边上.

<li>
为了确定哪条边形成该shaft的平面. 首先, 对于shaft它的AABB六个面中的每个面, 查找两个初始AABB中的哪个面与这个AABB接触在一起. 现在, 检查shaft其AABB的每条边, 如果shaft它的AABB有两个面以某一条边为共同的边, 且这两个面接触到不同的初始AABB, 则有一个平面通过连接这些初始AABB对应的边形成, 且该形成的平面加入shaft的定义中. 最多有八个平面可以添加进shaft中. 具体可见图16.27中的例子. 

<li>
对于shaft与其他AABB或者球体的相交测试, 首先图元依次与shaft的AABB以及而后每个平面进行测试, 如果图元完全在AABB或者任意平面外部, 则测试完成且shaft不和图元相交. 如果图元完全在所有平面之内, 则图元在shaft之内. 否则图元与shaft相交. 与一个shaft进行测试, 其为一系列的plane/AABB或plane/sphere测试, 当执行shaft/sphere测试时可能有false hit生成. shaft/box测试则为精确地.

<li>
Haines 和 Wallace 讨论了shaft形成和剔除的优化, 以及代码网上可用[483, 486].

</ul>

<h2 id="toc_1.16">16.16 Line/Line Intersection Tests</h2>
<h3 id="toc_1.16.1">16.16.1 Two Dimensions</h3>
<h4 id="toc_1.16.1.1">First Method</h4>
<ul>
<li>
考虑两个线条: R1(s) = O1 + sD1, R2(t) = O2 + tD2. 推导可见公式16.55.

<ul>
<li>
公式16.55

<li>


<li>


<li>


<li>


</ul>
<li>
如果D1和D2的垂直向量其点乘为0, 则两条线平行, 没有相交发生. 还有线段, 可以分别设置长度l1和l2, 或者设置O1 = P1, D1 = P2 - P1, 则 0 &lt;= s &lt;= 1, 该设置同样用于t. 对于带原点的射线ray, 有效范围为 s &gt;= 0, t &gt;= 0. 则相交点通过插入s到R1中或者插入t到R2中得到. 

</ul>

<h4 id="toc_1.16.1.2">Second Method</h4>
<ul>
<li>
Antonio[29]描述了另外一个方法确定两个线段是否相交, 其通过更多的比较, 初期的rejection, 以及避免之前公式中的昂贵计算(除法)来实现. 再次使用之前的符号, 有P1到P2的线段, 也有Q1到Q2的线段. 因此 R1(s) = P1 + s(P2-P1), R2(t) = Q1 + t(Q2-Q1). 则来自于公式16.55的结果可用于得到 R1(s) = R2(t) 的一个解决方案.

<ul>
<li>
公式16.56

<li>


<li>


<li>


<li>


<li>


<li>


</ul>
<li>
在公式16.56中, a = Q2 - Q1, b = P2 - P1, c = P1 - Q1, d = c点乘a的垂直向量, e = c点乘b的垂直向量, f = a点乘b的垂直向量. 对于因子s的简化步骤来自于这个事实, a的垂直向量点乘b = -b的垂直向量点乘a, a点乘b的垂直向量 = b的垂直向量点乘a. 如果a点乘b的垂直向量 = 0, 则两个线段共线. Antonio[29]发现分母对于s和t都一样, 则s和t不需要显式地. 可以略过除法操作. 定义 s = d/f, 以及 t = e/f. 去测试当 0 &lt;= s &lt;= 1, 则使用下面的代码:
<pre c++>
	if (f &gt; 0)
		if (d &lt; 0 or d &gt; f) return NO_INTERSECTION;
	else
		if(d &gt;0 or d&lt; f) return NO-INTERSECTION;
</pre>

<li>
在该测试之后, 其保证 0 &lt;= s &lt;= 1. 对于 t = e/f 同样也可以这么做, (在代码中将d换成e) 如果该程序在测试之后没有返回, 则线段相交, 这是由于t值也为有效的.

<li>
该程序的整数版本源代码可见网上[29]. 以及其可以很容易的转换成浮点数版本使用.

</ul>

<h3 id="toc_1.16.2">16.16.2 Three Dimensions</h3>
<ul>
<li>
线条为 R1(s) = O1 + sD1, R2(s) = O2 + tD2, 其对t值没有限制. 由于axa=0(自身叉乘为零), 则有公式16.58的推导.

<ul>
<li>
公式16.58

<li>


<li>


<li>


<li>


<li>


<li>


</ul>
<li>
Goldman[411]注意到, 如果分母||D1xD2||的平方为0, 此时两个线条平行. 如果两线条为skew(即不共享同一个平面)的, 则 s和t参数表示为它们之间最近的点.

<li>
如果线条处理为线段, 则长度l1和l2(假设方向D1和D2已被单元化), 则检查 0&lt;=s&lt;=l1和检查 0 &lt;= t &lt;= l2,如果都不为真, 则不相交.

<li>
Rhodes[1064]则给出了深入地解决方案来处理两个线条或线段的相交问题, 其给出了健壮的解决方案来处理特殊的情况, 其讨论了优化以及提供了源代码.

</ul>

<h2 id="toc_1.17">16.17 Intersection Between Three Planes</h2>
<ul>
<li>
给出三个平面, 求解它们的相交. 三个平面分别用法线Ni和其上的一点Pi表示. 则有公式16.59, 注意分母, 其为三个平面法线的行列式, 如果为零表示两个或多个平面平行.

<ul>
<li>
公式16.59

<li>


</ul>
<li>
该公式还可用于计算一个由平面集合组成的BV的角. 例如k-DOP, 其有k个平面公式组成. 公式16.59还可计算正确的平面组成的多面体的角.

<li>
如果平面由隐式表达式组成, 则计算距离原点最近的点, 从原点沿着法线方向发射一条线, 与其相交的点. 见公式16.60

<ul>
<li>
公式 16.60

<li>


</ul>
</ul>

<h2 id="toc_1.18">16.18 Dynamic Intersection Testing</h2>
<ul>
<li>
由于物体是一帧帧渲染的, 所以在帧之间的运动之后使用静态检测则可能错过了碰撞检测. 其中一个方法是使用一致的间隔在两帧之间执行一些检测, 但是其会增加计算加载, 以及仍可能错过相交. 所以动态相交测试则设计用于处理该问题, 本章节提供了该主题的介绍. 更多的信息可见Ericson[315]和Eberly[294]的书.

<li>
类似于 shaft culling(章节16.15)的方法可用于帮助移动AABB间的相交测试. 通过空间移动的物体可用不同时间的两个AABBs表示, 以及这两个AABBs可以通过一个shaft相连接. 然而, 当移动的物体包含在一个围绕球中时, 相交算法变得更简单和更快. 实际上, 使用少数球的集合来紧紧地贴住和表示一个移动物体是值得的[1137].

<li>
应用于只有平移(没有旋转)发生的动态相交测试状况的一个原则为运动是相对的这个事实. 例如物体A运动速度Va, 物体B运动速度Vb, 则计算时将物体B看成静止的, 物体A的运动速度为 Va - Vb

</ul>

<h3 id="toc_1.18.1">16.18.1 Sphere/Plane</h3>
<ul>
<li>
假设球的球心为c, 半径为r, 整个帧时为△t, 球的速度为v, 则下一帧球的球心位于 e = c + △tv. 为了简化, 假设△t为1, 该帧的起始时为0. 则问题为, 在两帧之间, 球是否与平面碰撞, 平面方程为 π: n・x + d = 0.

<li>
可以通过插入球心到平面公式得到有符号的距离Sc, 该距离减去半径r球表示球体沿着法线距离平面有多远. 具体可见图16.28. 可以计算终点e的一个类似的距离Se, 现在, 如果球心位于平面相同的一边(测试ScSe&gt;0), 且 |Sc| &gt; r以及|Se| &gt; r, 则相交不发生. 该球则可以安全地移动至e. 否则, 相交时的位置和精确时间可以计算出来, 球第一次接触到平面的t计算如下:

<ul>
<li>
公式16.61

<li>


<li>
此时球心则位于 c + tv, 一个简单的碰撞反应为围着平面法线反射速度向量v. 使用向量 (1-t)r移动球体, 1-t 为到下一帧所剩下的时间, r为反射向量.

</ul>
</ul>

<h3 id="toc_1.18.2">16.18.2 Sphere/Sphere</h3>
<ul>
<li>
测试两个球A和B的相交其结果是等价于测试一个ray和一个静止的球体---一个意外的结果. 由两个步骤, 首先使用相对移动设置球B为静止的. 而后借用frustum/sphere相交测试(章节16.14.2)的技术, 其设置球A为一个点, 设置球B其半径为原先球A和球B的半径之和. 见图16.29.

<li>
由于基本的测试可见章节16.6, 我们可以简单地发表最终的结果:

<ul>
<li>
公式16.62

<li>


</ul>
<li>
这个公式中Vab = Va - Vb, l = Ca - Cb, Ca和Cb分别为两球的中心. 

<li>
则给出了a, b, c

<ul>
<li>
公式16.63

<li>


<li>


</ul>
<li>
这些值可用于二次方程:

<ul>
<li>
公式 16.64

<li>


</ul>
<li>
可计算出两个根

<ul>
<li>
公式 16.65

<li>


</ul>
<li>
当b&gt;=0时sign(b)为+1, 否则为-1. 两个根如下:

<ul>
<li>
公式 16.66

<li>


</ul>
<li>
这个形式的二次方程解决通常不见于教科书所讲述的, 但是Press注意到这个更加的数字上稳定的[11034].

<li>
在[0, 1]之内的[t0, t1]范围其最小的值为第一次相交的时间, 插入t值到下面的公式

<ul>
<li>
公式 16.67

<li>


<li>


</ul>
<li>
其生成了每个球体第一次相交时的位置, 这个测试与早先ray/sphere测试的主要不同为ray的方向Vab这里不单元化.

</ul>

<h3 id="toc_1.18.3">16.18.3 Sphere/Polygon</h3>
<ul>
<li>
sphere/plane相交可以转换为与sphere/sphere相交所做那样类似的方式. 即移动的球可以收缩为一个移动的点, 而该平面则扩展为slab, 其厚度为球的直径. 这两个测试使用的关键思想为其所计算的内容称之为两个物体的Minkowski sum. 一个球与另一个球的Minkowski为一个更大的球体其半径等于两个球体的半径之和. 一个球和一个平面的Minkowski sum为一个平面在各个方向上加厚球半径长的长度. 任何两个volume都可以以这种方式加在一起, 虽然有时其结果很难描述. 对于一个动态的sphere/polygon测试其思路为测试一个ray与一个球和多边形的Minkowski sum.

<li>
Schroeder给出了算法的详细解释, 以及在网上提供了代码[1137]. 我们跟随他的报告, 根据需要做出修正. 显示 Minkowski sum 如何帮助解释该方法为何可以运作.

<li>
如果球不和平面重合, 则不需要进一步的测试. 之前发表的sphere/plane测试可发现何时球与平面第一次相交. 该相交点可用于执行一个点在多边形(point in polygon)中的测试(章节16.9). 如果该点在多边形内, 则球首先击中多边形, 而后测试完成.

<li>
然而该击中点可以在多边形之外, 但球体在沿着其路径进一步移动中可以击中多边形边或者点. 如果通过该边球球与一个无限长的线条碰撞. 则球上的第一个相交的点p其距离球心永远为半径r的大小, 则有公式:

<ul>
<li>
公式 16.68

<li>


</ul>
<li>
其中Ct = C + tV. 球的初始位置为c, 速度为v. 当然, 球心到该点的向量垂直于该边:

<ul>
<li>
公式 16.69

<li>


</ul>
<li>
这里, P0和P1为多边形边上的点. 该击中点的位置P在多边形的线上, 有下面的参数方程定义:

<ul>
<li>
公式 16.70

<li>


</ul>
<li>
其中d为到P0的相对位置, d属于[0, 1]范围, 表示该边上的点.

<li>
这个变量以计算与该边的线条第一次相交的时间t和沿着该边的距离d. 对于t其有效的相交范围为[0, 1]. 即为两帧间的时间内. 如果t被发现在该范围之外, 则碰撞不在该帧时间内发生. d的有效范围也为[0, 1]. 也就是, 该hit point必须位于该边上, 而不是在该边的端点之外. 见图16.30.

<li>
则有两个公式集和两个未知变量如下:

<ul>
<li>
公式 16.71

<li>


<li>


<li>
公式 16.72

<li>


<li>


<li>
公式 16.73

<li>


<li>


</ul>
<li>
注意 Ks = V, 一帧内的速度向量. e为球的目标位置. 则给出a, b, c, 其为页面786中的二次方程中的变量, 因此以同样的方式求解T0和T1. 

<ul>
<li>
公式 16.74

<li>


</ul>
<li>
这个d求解范围须在[0, 1]内, 如果d不在这个范围, 则没有和该边相交. 使用公式16.70中的d, 其给出球与该边第一次相交的点. 注意, 如果需要第一次相交的点, 所有三个边都需要与该球测试, 该球可能击中多于一条边.

<li>
sphere/edge test计算上复杂的, 用于该测试的一个优化为放置一个AABB围绕球的路径, 以用于在执行完全测试之前在该帧以及测试该边为一个ray与该box. 如果线段不重合AABB, 则该边不可能和球相交[1137].

<li>
如果没有边为用于该球相交的第一个点, 需要进一步的测试, 回忆测试该球与多边形相交的第一个点. 一个球可能最终击中多边形的内部或者一条边, 但这里给出的测试只检查第一个相交(first intersection). 第三个可能为第一个相交的点为多边形顶点. 所以每个顶点依次地与球体测试, 使用相对移动的概念, 测试一个移动的球体与一个精致的点等同于测试一个球体与一个运动的点. 也就是, 一个ray. 使用章节16.6中的ray/sphere相交程序, 其为所有需要的. 测试ray Ct = C + tV 与一个中心在P0, 半径为r的球体, 其结果可以被重用. 从之前的边计算解出t, 如下:

<ul>
<li>
公式 16.75

<li>


<li>


<li>


</ul>
<li>
使用这种形式可以避免单元化ray方向以避免ray/sphere相交. 如前所述, 在帧中球第一次和顶点相交时, 解公式16.64中的二次方程, 以及使用最低的有效根来计算. 该相交的点为顶点自身.

<li>
事实上, 这个 sphere/polygon 测试等同于测试一个ray(由沿着一条线移动的球心表示)与球和多边形的Minkowski sum. 该summed的表面(surface)其顶点被转换为一个半径为r的球体. 其边则成为一个半径为r的圆柱体, 多边形则上升和下降r个单位来封闭该物体. 见图16.31所示, 其与frustum/sphere相交所做的为相同类型的扩张(章节16.14.2). 所以该算法可看成测试一个ray与一个volume的部分. 首先, 面向该ray的polygon被测试, 然后测试边的圆柱体与该ray, 最后测试顶点球体.

<li>
接下来讲述了为何按照这个测试顺序进行测试. 另外一般在测试圆柱体边时就可以结束测试, 这是因为最近的圆柱体外部(exterior)相交永远比最近的顶点球相交更近.

<li>
该膨胀物体模型的另一个理解为, 对于凹状的多边形, 任何位于凹处位置的顶点不必移动的球体测试. 这是因为在类似的顶点上其形成的球体不被外部所见. 有效的动态sphere/object相交测试可以由相对移动以及一个移动球体通过使用Minkowski sums转换为一个ray的变换推导出.

</ul>

<h3 id="toc_1.18.4">16.18.4 Dynamic Separating Axis Method</h3>
<ul>
<li>
页面731的separating axis test(SAT)对于测试凸多面体非常有用. 例如, box和三角形, 之间相互的相交. 这个可以相当容易地扩展为dynamic queries[124, 292, 315, 1131].

<li>
记住这个SAT方法, 其测试一系列轴查看是否两个物体的投影在这些轴上重合. 如果所有轴上的投影重合, 则该物体重合. 解决该动态问题的关键为, 以速度 (V・a)/(a・a)(公式 A.17)移动该运动物体的投影的间隔(projected interval). 再次, 如果其在所有轴上重合, 则该动态物体重合, 否则不重合. 可见图16.32的诠释. 其描述了静止不动的SAT和动态的STA之间的不同.

<li>
Eberly[292], 使用了一个Ron Levine的思路, 也计算A和B之间相交的实际时间. 通过计算当他们开始重合的时间Ts, 以及他们停止重合的时间(这是由于移动相互通过对方)Te. A与B之间的hit发生在对于所有轴上所有的TsS中最大的那个之上. 同样的, 停止重合发生在所有TeS最小的那个. 优化包括检测在t=0时, 何时该interval为不重合的, 以及同样何时移动分开. 同样, 如果任意时候最大的Ts大于最小的Te, 则物体没有重合, 所以该测试种植. 其类似于章节16.7.1的ray/box相交测试. Eberly有代码用于很广范围的凸多面体之间的测试, 包括 box/box. triangle/box, 以及 triangle/triangle.

</ul>

</body>
</html>
