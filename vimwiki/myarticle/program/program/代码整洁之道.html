<html>
<head>
    <link rel="Stylesheet" type="text/css" href="../../../style.css" />
    <title>֮</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
</head>
<body>
<div id="all">
<div id="header">
	<ul id="top-nav">
		<li>
			<a href="../index.html">首页</a>
		</li>
	</ul>
</div>
</div>
    <div class="content">
    
<div id="第2章 有意义的命名"><h1 id="第2章 有意义的命名" class="header"><a href="#第2章 有意义的命名">第2章 有意义的命名</a></h1></div>
<ul>
<li>
如果名称需要注释来补充，那不就算是名副其实。

<li>
不使用数字字面常量。用有意义的名称表示

<li>
内置类型的数组使用别名表示

<li>
不要使用不同之处较小的名称

<li>
以数字序列(a1,a2,...,aN)命名是没有意义的区分. 废话是另外一种没有意义的区分. Info 和 Data 就像 a, an和the一样，都是意义含混的废话. 但可以用"a"做域内变量，"the"做函数参数。

<li>
变量名称要能够读出来。

<li>
变量名要长一点，方便搜索

<li>
匈牙利标记法容易引起误解，附带的类型缩写可能与当前的类型名不一致

<li>
类成员名不需要 "m_" 这样的前缀

<li>
名称不需要在脑中进行二次翻译

<li>
类名和对象名应该是名词或名词短语，方法名应当是动词或动词短语

<li>
可以用类的静态方法返回类对象的实例

<li>
不要用古怪的名称

<li>
每个概念对应一个词，如 fetch, retrieve, get 只取一个， controller, manager, driver 只取一个

<li>
一个单词不要有多个意思，add不要表示加法，又表示将一个元素加入一个容器。

<li>
尽量使用技术性名称，例如设计模式内的一般用语。 尽量用那些计算机科学术语，算法名，模式名，数学术语

<li>
使用源自所涉问题领域的名称

<li>
给名称添加有意义的语境。 addrFirstName, addrLastName, addrState

<li>
不要添加没用的语境

</ul>

<div id="第3章 函数"><h1 id="第3章 函数" class="header"><a href="#第3章 函数">第3章 函数</a></h1></div>
<ul>
<li>
函数不应该大到足以容纳嵌套结构。函数的缩进层级不该多于一层或两层。

<li>
函数只做一件事情，(一个层级下的所有步骤只算一件事情)

<li>
对于 switch 语句，一般只出现一次，用于创建多态对象。

<li>
泰半工作在于为只做一件事的小函数取个好名字。

<li>
有足够特殊的理由才能用三个以上的参数。

<li>
尽量不要使用输出参数

<li>
标识参数丑陋不堪，像函数传入布尔值简直就是骇人听闻的做法，不如用两个函数来代替。

<li>
尽量将二元函数转换成一元函数

<li>
如果函数看来需要两个、三个或三个以上参数，就说明其中一些参数应该封装成类了。

<li>
对于一元函数，函数和参数应当形成一种非常良好的动词/名词对形式。如 write(name), writeField(name).

<li>
参数的名称编码成函数名。 assertEqual 改成 assertExpectedEqualsActual(expected, actual).

<li>
避免使用输出参数，如果函数必须修改某种状态，就修改所属对象的状态吧。 public void appendFooter(StringBuffer report) 改成 report.appendFooter()

<li>
函数要么修改所属对象的状态，要么返回该对象的有关信息。不可二者兼得。

<li>
如果使用异常替代错误码，错误处理代码就能从主路径代码中分离出来，得到简化。

<li>
最好把 try 和 catch 代码块的主体部分抽离出来，另外形成函数。

</ul>

<div id="第4章 注释"><h1 id="第4章 注释" class="header"><a href="#第4章 注释">第4章 注释</a></h1></div>
<ul>
<li>
不准确的注释要比没注释坏得多。

<li>
创建一个描述与注释所言同一事务的函数来消除多余的注释。

<li>
注释可以描述某个决定后的意图

<li>
阐释某些晦涩难明的参数或返回值的意义为某种可读形式。前提是参数或返回值你不能修改。

<li>
注释警告其他程序员会出现某种后果。

<li>
<span class="todo">TODO</span> 注释，注意经常查看

<li>
如果你决定写注释，就要花必要的时间确保写出最好的注释

<li>
不要有日志性注释，使用版本控制器解决。

<li>
能用函数名或变量名时就别用注释。

<li>
花括号后面的注释，通过缩短函数来解决。

<li>
不要保留注释掉的代码，适用版本控制器来做这些事情。

<li>
注释要描述离它最近的代码

</ul>

<div id="第5章 格式"><h1 id="第5章 格式" class="header"><a href="#第5章 格式">第5章 格式</a></h1></div>
<ul>
<li>
每个空白行都是一条线索，标识出新的概念

<li>
概念相关的代码应该放到一起，例如执行相似操作的一组函数。

<li>
被调用的函数应该放在执行调用的函数下面。

<li>
一行代码的上限是120个字符

<li>
空格还可以展示操作符的优先级
<pre c++>
b*b - 4*a*c;
</pre>

<li>
不再尝试多行变量声明中的列对齐

<li>
while 或 if 的空语句用花括号括起来。

</ul>

<div id="第6章 对象和数据结构 "><h1 id="第6章 对象和数据结构 " class="header"><a href="#第6章 对象和数据结构 ">第6章 对象和数据结构 </a></h1></div>
<ul>
<li>
将变量设置为私有(private)有一个理由，不想其他人依赖这些变量，那为何还需要给其添加赋值器和取值器。

<li>
隐藏的目的在于抽象，暴露抽象接口，但用户无法知道内部的数据结构。下面的抽象点就很好的描述了这一点
<pre c++>
// 具象点
public class Point {
	public double x;
	public double y;
};

// 抽象点
public interface Point {
	double getX();
	double getY();
	void setCartesian(double x, double y);
	double getR();
	double getTheta();
	void setPolar(double r, double theta);
};
</pre>

<li>
对象把数据隐藏于抽象之后，曝露操作数据的函数。数据结构曝露其数据，没有提供有意义的函数。

<li>
过程式代码(使用数据结构的代码)便于在不改动既有数据结构的前提下添加新韩淑。面向对象代码便于在不改动现有函数的前提下添加新类

<li>
得墨忒耳律认为，类C的方法f只应该调用以下对象的方法:

<ul>
<li>
this对象

<li>
由f创建的对象

<li>
作为参数传递给f的对象

<li>
由this对象所持有的对象

</ul>
<li>
方法不应调用由任何函数返回的对象的方法

<li>
注意得墨忒耳律只适用于对象，不适用于数据结构。如果函数返回的是数据结构，可以调用该数据结构的方法

<li>
只有公共变量，没有函数的类。称之为数据传送对象，或DTO(Data Transfer Bbjects), DTO 常用于与数据库通信、或解析套接字传递的消息之类场景中。

</ul>

<div id="第7章 错误处理"><h1 id="第7章 错误处理" class="header"><a href="#第7章 错误处理">第7章 错误处理</a></h1></div>
<ul>
<li>
使用异常而非返回码

<li>
可控异常的代价就是违反开放/闭合原则。

<li>
异常应该创建信息充分的错误消息，并和异常一起传递出去。消息应该包含失败的操作和失败类型。

</ul>

<div id="第8张 边界"><h1 id="第8张 边界" class="header"><a href="#第8张 边界">第8张 边界</a></h1></div>
<ul>
<li>
软件边界：将外来代码整合进自己的代码

<li>
Java 通过编写测试来遍览和理解第三方代码

<li>
学习性测试还可以发现新版本的第三方程序包是否依然可以运行。

</ul>

    </div>
</body>
</html>
